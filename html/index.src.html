<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
	"http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>

<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>asm.js</title>
<link rel="stylesheet" type="text/css" href="whatwg.css">
<link rel="stylesheet" type="text/css" href="github.css">
<script src="highlight.pack.js"></script>
<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
<script>
$(document).ready(function() {
    $("div.example pre").each(function(i, e) {
        e.className = "language-javascript";
        hljs.highlightBlock(e);
    });
});
</script>
<style>
span.seq {
  border-top: solid 1px black;
}
span.meta {
  color: darkgray;
  font-size: 120%;
  margin: 0 0.2ex;
}
</style>

<body class="draft">

<div class="head">
	<h1>[TITLE]</h1>
	
	<h2 class="no-num no-toc">Working Draft â€” [DATE]</h2>
	
	<dl>
		<dt>Latest version:
		<dd><!--begin-link-->http://asmjs.org/spec/latest/<!--end-link-->
		
		<dt>Editors:
		<dd class="vcard">
			<span class="fn">David Herman</span>,
			<span class="org">Mozilla</span>,
			<span class="email">&lt;dherman@mozilla.com&gt;</span>
		<dd class="vcard">
			<span class="fn">Luke Wagner</span>,
			<span class="org">Mozilla</span>,
			<span class="email">&lt;luke@mozilla.com&gt;</span>
		<dd class="vcard">
			<span class="fn">Alon Zakai</span>,
			<span class="org">Mozilla</span>,
			<span class="email">&lt;azakai@mozilla.com&gt;</span>
	</dl>
</div>

<h2 class="no-num no-toc">Abstract</h2>

<p>This specification defines <strong>asm.js</strong>, a strict subset
of JavaScript that can be used as a low-level, efficient target
language for compilers. This sublanguage effectively describes a safe
virtual machine for memory-unsafe languages like C or C++. A
combination of static and dynamic validation allows JavaScript engines
to employ an ahead-of-time (AOT) optimizing compilation strategy for
valid asm.js code.

<h2 class="no-num no-toc">Status</h2>

<p>This specification is working towards a candidate draft for asm.js
version 1. A prototype implementation of an optimizing backend for
asm.js is in progress for Mozilla's SpiderMonkey engine.

<h2 class="no-num no-toc">Table of Contents</h2>

<!--toc-->

<h2>Introduction</h2>

<p>This specification defines <dfn>asm.js</dfn>, a strict subset of
JavaScript that can be used as a low-level, efficient target language
for compilers. The asm.js language provides an abstraction similar to
the C/C++ virtual machine: a large binary heap with efficient loads
and stores, integer and floating-point arithmetic, first-order
function definitions, and function pointers.

<h3 class="no-toc no-num">Programming Model</h3>

<p>The asm.js programming model is built around integer and
floating-point arithmetic and a virtual heap represented as
a <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays">typed
array</a>. While JavaScript does not directly provide constructs for
dealing with integers, they can be emulated using two tricks:

<ul>
<li>integer loads and stores can be performed using the typed arrays
API; and
<li>integer arithmetic is equivalent to the composition of
JavaScript's floating-point arithmetic operators with the integer
coercions performed by the bitwise operators.
</ul>

<p>As an example of the former, if we have
an <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/Int32Array">Int32Array</a>
view of the heap called <code>HEAP32</code>, then we can load the
32-bit integer at byte offset <code>p</code>:

<!--
<p>As an example of a load from the heap, if we have a 2MB heap
(i.e., <code>0x200000</code> bytes) and
an <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/Int32Array">Int32Array</a>
view of the heap called <code>HEAP32</code>, then we can load the
32-bit integer at byte offset <code>p</code>:
-->

<div class="example">
<pre>HEAP32[p >> 2]|0</pre>
</div>

<p>The shift converts the byte offset to a 32-bit word offset, and the
bitwise coercion ensures that an out-of-bounds access is coerced
from <code>undefined</code> back to an integer.

<!--
<p>The mask is required by asm.js in order to efficiently enforce that
the pointer is within the heap array's bounds, and the shift converts
the byte offset to a 32-bit word offset.
-->

<p>As an example of integer arithmetic, addition can be performed by
taking two integer values, adding them with the built-in addition
operator, and coercing the result back to an integer via the bitwise
or operator:

<div class="example">
<pre>(x+y)|0</pre>
</div>

<p>This programming model is directly inspired by the techniques
pioneered by the <a href="http://emscripten.org">Emscripten</a>
compiler.

<h3 class="no-num no-toc">Validation</h3>

<p>The asm.js sub-language is defined by a
<a href="#validation-rules">static type system</a> that can be checked
at JavaScript parse time. Validation of asm.js code is designed to be
"pay-as-you-go" in that it is never performed on code that does not
request it. An asm.js <dfn>module</dfn> requests validation by means
of a
special <a href="http://ecma-international.org/ecma-262/5.1/#sec-14.1">prologue
directive</a>, similar to that of ECMAScript Edition
5's <a href="http://ecma-international.org/ecma-262/5.1/#sec-10.1.1">strict
mode</a>:

<div class="example">
<pre>function MyAsmModule() {
    "use asm";
    // module body
}</pre>
</div>

<p>This explicit directive allows JavaScript engines to avoid
performing pointless and potentially costly validation on other
JavaScript code, and to report validation errors in developer consoles
only where relevant.

<h3 class="no-num no-toc">Ahead-Of-Time Compilation</h3>

<p>Because asm.js is a strict subset of JavaScript, this specification
only defines the validation logic&mdash;the execution semantics is
simply that of JavaScript. However, validated asm.js is amenable to
ahead-of-time (AOT) compilation. Moreover, the code generated by an
AOT compiler can be quite efficient, featuring:

<ul>
<li>unboxed representations of integers and floating-point numbers;
<li>absence of runtime type checks;
<li>absence of garbage collection; and
<li>efficient heap loads and stores (with implementation strategies varying by platform).
</ul>

<p>Code that fails to validate must fall back to execution by
traditional means, e.g., interpretation and/or just-in-time (JIT)
compilation.

<!--
Moreover, the low-level nature of validated asm.js code makes it
possible for AOT implementations to perform aggressive optimizations
without profiling, heuristics, or dynamic deoptimization or
recompilation.
-->

<h3 class="no-num no-toc">Linking</h3>

<p>Using an asm.js module requires calling its function to obtain an
object containing the module's exports; this is known
as <dfn>linking</dfn>. An asm.js module can also be given access to
standard libraries and custom JavaScript functions through linking. An
AOT implementation must perform certain <a href="#linking-0">dynamic
checks</a> to check compile-time assumptions about the linked
libraries in order to make use of the compiled code.

<p>This figure depicts a simple architecture of an AOT implementation
that otherwise employs a simple interpreter. If either dynamic or
static validation fails, the implementation must fall back to the
interpreter. But if both validations succeed, calling the module
exports executes the binary executable code generated by AOT
compilation.

<figure class="diagrams">
<img src="aot.png" width="780" height="241">
</figure>

<h3 class="no-num no-toc">External Code and Data</h3>

<p>Within an asm.js module, all code is fully statically typed and
limited to the very restrictive asm.js dialect. However, it is
possible to interact with recognized standard JavaScript libraries and
even custom dynamic JavaScript functions.

<p>An asm.js module can take up to three optional parameters,
providing access to external JavaScript code and data:

<ul>
<li>a <dfn>standard library</dfn> object, providing access to a
limited subset of the JavaScript <a href="#standard-library">standard
libraries</a>;
<li>a <dfn>foreign function interface</dfn> (FFI), providing access to
custom external JavaScript functions; and
<li>a <dfn>heap buffer</dfn>, providing a
single <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBuffer"><code>ArrayBuffer</code></a>
to act as the asm.js heap.
</ul>

<p>These objects allow asm.js to call into external JavaScript (and to
share its heap buffer with external JavaScript). Conversely, the
exports object returned from the module allows external JavaScript to
call into asm.js.

<p>So in the general case, an asm.js module declaration looks like:

<div class="example">
<pre>function MyAsmModule(stdlib, foreign, heap) {
    "use asm";

    // module body...

    return {
        export1: f1,
        export2: f2,
        // ...
    };
}
</div>

<p>Function parameters in asm.js are provided a type annotation by
means of an explicit coercion on function entry:

<div class="example">
<pre>function diag(x, y) {
    x = +x; // x has type double
    y = +y; // y has type double
    return +sqrt(square(x) + square(y));
}</pre>
</div>

<p>These annotations serve two purposes: first, to provide the
function's type signature so that the validator can enforce that all
calls to the function are well-typed; second, to ensure that even if
the function is exported and called by external JavaScript, its
arguments are dynamically coerced to the expected type. This ensures
that an AOT implementation can use unboxed value representations,
knowing that once the dynamic coercions have completed, the function
body never needs any runtime type checks.

<h3 class="no-num no-toc">Putting It All Together</h3>

<p>The following is a simple but complete example of an asm.js module.

<!--
<p>As a simple example, the following module imports the
standard <code>Math.sqrt</code> library function. At link time, the
engine must verify that the function extracted
from <code>stdlib.Math.sqrt</code> is actually the original
<code>Math.sqrt</code> function of the JavaScript standard library:
-->

<div class="example">
<pre>function DiagModule(stdlib) {
    "use asm";

    var sqrt = stdlib.Math.sqrt;

    function square(x) {
        x = +x;
        return +(x*x);
    }

    function diag(x, y) {
        x = +x;
        y = +y;
        return +sqrt(square(x) + square(y));
    }

    return { diag: diag };
}</pre>
</div>

<p>In a JavaScript engine that supports AOT compilation of asm.js,
calling the module on a true global object would produce a fully
compiled exports object:

<div class="example">
<pre>var fast = DiagModule(window);     // produces AOT-compiled version
console.log(fast.diag(3, 4));      // 5</pre>
</div>

<p>By contrast, calling the module on a standard library object
containing something other than the true <code>Math.sqrt</code> would
fail to produce compiled code:

<div class="example">
<pre>var bogusGlobal = {
    Math: {
        sqrt: function(x) { return x * 2; }
    }
};

var slow = DiagModule(bogusGlobal); // produces purely-interpreted version
console.log(slow.diag(3, 4));       // 50</pre>
</div>


<h2>Types</h2>

<p>Validation of an asm.js module relies on a static type system that
classifies and constrains the syntax. This section defines the types
used by the validation logic.

<h3>Value Types</h3>

<p>Validation in asm.js limits JavaScript programs to only use operations
that can be mapped closely to efficient data representations and
machine operations of modern architectures, such as 32-bit integers
and integer arithmetic.

<p>The types of asm.js values are inter-related by a subtyping
relation, which can be represented pictorially:

<figure class="diagrams">
<img src="subtypes.png" width="480" height="396">
</figure>

<p>The white boxes represent arbitrary JavaScript values that may flow
freely between asm.js code and external JavaScript code.

<p>The gray boxes represent types that are disallowed from escaping
into external (i.e., non-asm.js) JavaScript code. (These values can be
given efficient, unboxed representations in optimized asm.js
implementations that would be unsound if they were allowed to escape.)

<p>The meta-variables &sigma; and &tau; are used to stand for value
types.

<h4>void</h4>

<p>The <dfn><code>void</code></dfn> type is the type of functions that
are not supposed to return any useful value. As JavaScript functions,
they produce the <code>undefined</code> value, but asm.js code is not
allowed to make use of this value; functions with return
type <code>void</code> can only be called for effect.

<h4>double</h4>

<p>The <dfn><code>double</code></dfn> type is the type of ordinary
JavaScript double-precision floating-point numbers.

<h4>signed</h4>

<p>The <dfn><code>signed</code></dfn> type is the type of signed
32-bit integers. While there is no direct concept of integers in
JavaScript, 32-bit integers can be represented as doubles, and integer
operations can be performed with JavaScript arithmetic, relational,
and bitwise operators.

<h4>unsigned</h4>

<p>The <dfn><code>unsigned</code></dfn> type is the type of unsigned
32-bit integers. Again, these are not a first-class concept in
JavaScript, but can be represented as floating-point numbers.

<h4>int</h4>

<p>The <dfn><code>int</code></dfn> type is the type of 32-bit integers
where the signedness is not known. In asm.js, the type of a variable
never has a known signedness. This allows them to be compiled as
32-bit integer registers and memory words. However, this
representation creates an overlap between signed and unsigned numbers
that cause an ambiguity in determining which JavaScript number they
represent. For example, the bit pattern <code>0xffffffff</code> could
represent 4294967295 or -1, depending on the signedness. For this
reason, values of the <code>int</code> type are disallowed from
escaping into external (non-asm.js) JavaScript code.

<h4>fixnum</h4>

<p>The <dfn><code>fixnum</code></dfn> type is the type of integers in the
range [0, 2<sup>31</sup>)&mdash;that is, the range of integers such
that an unboxed 32-bit representation has the same value whether it is
interpreted as signed or unsigned.


<h4>intish</h4>

<p>Even though JavaScript only supports floating-point arithmetic,
most operations can simulate integer arithmetic by coercing their
result to an integer. For example, adding two integers may overflow
beyond the 32-bit range, but coercing the result back to an integer
produces the same 32-bit integer as integer addition in, say, C.

<p>The <dfn><code>intish</code></dfn> type represents the result of a
JavaScript integer operation that must be coerced back to an integer
with an explicit coercion
(<a href="http://ecma-international.org/ecma-262/5.1/#sec-9.5"><em>ToInt32</em></a>
for signed integers
and <a href="http://ecma-international.org/ecma-262/5.1/#sec-9.6"><em>ToUint32</em></a>
for unsigned integers). Validation requires all <code>intish</code>
values to be immediately passed to an operator or standard library
that performs the appropriate coercion or else dropped via an
expression statement. This way, each integer operation can be
compiled directly to machine operations.

<p>The one operator that does not support this approach is
multiplication. (Multiplying two large integers can result in a large
enough double that some lower bits of precision are lost.) So asm.js
does not support applying the multiplication operator to integer
operands. Instead, the
proposed <a href="https://mail.mozilla.org/pipermail/es-discuss/2012-November/026126.html"><code>Math.imul</code></a>
function is recommended as the proper means of implementing integer
multiplication.


<h4>doublish</h4>

Similar to <code>intish</code>, the <dfn><code>doublish</code></dfn>
type represents operations that are expected to produce
a <code>double</code> but may produce additional junk that must be
coerced back to a number
via <a href="http://ecma-international.org/ecma-262/5.1/#sec-9.3"><em>ToNumber</em></a>. In
particular, reading out of bounds from a typed array
produces <code>undefined</code>, and calling FFI functions may produce
arbitrary JavaScript values.

<h4>unknown</h4>

The <dfn><code>unknown</code></dfn> type represents a value returned
from an FFI call. Since asm.js does not allow general JavaScript
values, the result must be immediately coerced to an integer or
double.

<h4>extern</h4>

The abstract <dfn><code>extern</code></dfn> type represents the root
of all types that can escape back into external JavaScript&mdash;in
other words, the white boxes in the above diagram.

<h3>Global Types</h3>

<p>Variables and functions defined at the top-level scope of an asm.js
module can have additional types beyond
the <a href="#value-types">value types</a>. These include:

<ul>
<li>value types &tau;;
<li><a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a> types <code>Int<em>n</em>Array</code>, <code>Uint<em>n</em>Array</code>, and <code>Float<em>n</em>Array</code>;
<li>function types ((&sigma;, &hellip;) &rarr; &tau;) &and; &hellip; &and; ((&sigma;&prime;, &hellip;) &rarr; &tau;&prime;); and
<li>the FFI function type <code>Function</code>.
</ul>

<!-- FIXME: example with link to operators -->
The "&and;" notation for function types serves to represent overloaded functions and operators. For example...

<p>The meta-variable &gamma; is used to stand for global types.

<h2>Environments</h2>

<p>Validating an asm.js module depends on tracking contextual
information about the set of definitions and variables in scope. This
section defines the <dfn>environments</dfn> used by the validation
logic.

<h3>Global Environment</h3>

<p>An asm.js module is validated in the context of a <dfn>global
environment</dfn>. The global environment maps each global variable to
its type as well as indicating whether the variable is mutable:

<p><div>{ <em>x</em> : <span class="meta">(</span><tt>mut<span class="meta">|</span>imm</tt><span class="meta">)</span> &gamma;, &hellip; }</div>

<p>The meta-variable &Delta; is used to stand for a global environment.

<h3>Variable Environment</h3>

<p>In addition to the <span>global environment</span>, each function
body in an asm.js module is validated in the context of
a <dfn>variable environment</dfn>. The variable environment maps each
function parameter and local variable to its value type:

<p>{ <em>x</em> : &tau;, &hellip; }

<p>The meta-variable &Gamma; is used to stand for a variable environment.

<h3>Environment Lookup</h3>

<p>Looking up a variable's type

<div class="example">
<em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>)
</div>

<p>is defined by:

<ul>
<li>&tau; if <em>x</em> : &tau; occurs in &Gamma;;
<li>&gamma; if <em>x</em> does not occur in &Gamma; and <em>x</em>
: <code>mut</code> &gamma; or <em>x</em> : <code>imm</code> &gamma;
occurs in &Delta;
</ul>

<p>If <em>x</em> does not occur in either environment then
the <em>Lookup</em> function has no result.

<h2>Syntax</h2>

<p>Validation of an asm.js module is specified by reference to
the <a href="http://ecma-international.org/ecma-262/5.1/#sec-A">ECMAScript
grammar</a>, but conceptually operates at the level of abstract
syntax. In particular, an asm.js validator must obey the following
rules:

<ul>
<li>Empty statements (<code>;</code>) are always ignored, whether in
the top level of a module or inside an asm.js function body.
<li>No variables bound anywhere in an asm.js module (whether in the
module function parameter list, global variable declarations, asm.js
function names, asm.js function parameters, or local variable
declarations) may have the name <code>eval</code>
or <code>arguments</code>.
</ul>

<p>These rules are otherwise left implicit in the rest of the
specification.

<!-- FIXME: example -->
<p>Where necessary, the specification also defines non-terminals that
do not appear in
the <a href="http://ecma-international.org/ecma-262/5.1/#sec-A">ECMAScript
grammar</a>. These are always prefixed by the name <em>Asm</em> and
always denote subsets of a non-terminal in the official grammar. For
example, ...

<h2>Annotations</h2>

<p>All variables in asm.js are explicitly annotated with type
information so that their type can be statically enforced by
validation.

<h3>Parameter Type Annotations</h3>

<p>Every parameter in an asm.js function is provided with an explicit
type annotation in the form of a coercion. This coercion serves two
purposes: the first is to make the parameter type statically apparent
for validation; the second is to ensure that if the function is
exported, the arguments dynamically provided by external JavaScript
callers are coerced to the expected type. For example, a bitwise OR
coercion annotates a parameter as having type <code>int</code>:

<div class="example">
<pre>function add1(x) {
    x = x|0; // x : int
    return (x+1)|0;
}</pre>
</div>

<p>In an AOT implementation, the body of the function can be
implemented fully optimized, and the function can be given two entry
points: an internal entry point for asm.js callers, which are
statically known to provide the proper type, and an external dynamic
entry point for JavaScript callers, which must perform the full
coercions (which might involve arbitrary JavaScript computation, e.g.,
via implicit calls to <code>valueOf</code>).

<p>There are two recognized parameter type annotations:

<div class="example">
<em>x:Identifier</em> <code>=</code> <em>x:Identifier</em><code>|0;</code><br>
<em>x:Identifier</em> <code>=</code> <code>+</code><em>x:Identifier</em><code>;</code>
</div>

<p>The first form annotates a parameter as type <code>int</code>, and
the second as type <code>double</code>.

<h3>Return Type Annotations</h3>

<p>An asm.js function's return type is determined by the last
statement in the function body, which is required to be
a <em>ReturnStatement</em>. An asm.js return statement may take one
of three forms:

<div class="example">
<code>return +</code><em>e:Expression</em><code>;</code><br>
<code>return </code><em>e:Expression</em><code>|0;</code><br>
<code>return </code><em>n:NumericLiteral</em><code>;</code><br>
</div>

<p>The first form has return type <code>double</code>. The second has
type <code>signed</code>. The third has return
type <code>double</code> if <em>n</em> is a floating-point literal,
i.e., a numeric literal with the character <code>.</code> in its
source; alternatively, if <em>n</em> is an integer literal in the
range [-2<sup>31</sup>, 2<sup>31</sup>), the return statement has
return type <code>signed</code>.

<h3>Function Type Annotations</h3>

<p>The type of a function declaration

<div class="example">
<code>function</code> <em>f:Identifier</em><code>(</code><em>x:Identifier</em>&hellip;<code>) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><em>x:Identifier</em> <code>=</code> <em>AssignmentExpression</em><code>;</code><span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><code>var </code><span class="meta">(</span><em>y:Identifier</em> <code>=</code> <em>n:NumericLiteral</em><span class="meta">)</span><code>,</code>&hellip;<span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>body:Statement</em>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>return:ReturnStatement</em><br>
<code>}</code>
</div>

<p>is (&sigma;,&hellip;) &rarr; &tau; where &sigma;,&hellip; are the
types of the parameters, as provided by the <a href="">parameter type
annotations</a>, and &tau; is the return type, as provided by
the <a href="">return type annotation</a>. The variable <em>f</em> is
stored in the <a href="">global environment</a> with
type <code>imm</code> (&sigma;,&hellip;) &rarr; &tau;.

<h3>Variable Type Annotations</h3>

<p>The types of variable declarations are determined by their
initializer. A variable initializer may be a floating-point literal,
which is any numeric literal with the character <code>.</code> in
their source, and has type <code>double</code>. Alternatively, an
initializer may be an integer literal in the range [-2<sup>31</sup>,
2<sup>32</sup>), which has type <code>int</code>.

<h3>Global Variable Type Annotations</h3>

<p>A global variable declaration is a <em>VariableStatement</em> node
in one of several allowed forms.

<p>A global program variable is initialized to a literal:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>n:NumericLiteral</em><code>;</code>
</div>

<p>The global variable <em>x</em> is stored in the <a href="">global
environment</a> with type <code>mut</code> &tau;, where &tau; is
determined in the same way as local <a href="">variable type
annotations</a>.

<p>A standard library import is of one of the following two forms:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>stdlib:Identifier</em><code>.</code><em>y:Identifier</em><code>;</code><br>
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>stdlib:Identifier</em><code>.Math.</code><em>y:Identifier</em><code>;</code>
</div>

<p>The variable <em>stdlib</em> must match the first parameter of
the <a href="">module declaration</a>. The global variable <em>x</em>
is stored in the <a href="">global environment</a> with
type <code>imm</code> &gamma;, where &gamma; is the type of
library <em>y</em> or <code>Math.</code><em>y</em> as specified by
the <a href="">standard library types</a>.

<p>A foreign import is of one of the following three forms:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>foreign:Identifier</em><code>.</code><em>y:Identifier</em><code>;</code>
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>foreign:Identifier</em><code>.</code><em>y:Identifier</em><code>|0;</code><br>
<code>var</code> <em>x:Identifier</em> <code>=</code> <code>+</code><em>foreign:Identifier</em><code>.</code><em>y:Identifier</em><code>;</code>
</div>

<p>The variable <em>foreign</em> must match the second parameter of
the <a href="">module declaration</a>. The global variable <em>x</em>
is stored in the <a href="">global environment</a> with type <code>imm
Function</code> for the first form, <code>imm int</code> for the
second, and <code>imm double</code> for the third.

<p>A global heap view is of the following form:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>= new</code> <em>stdlib:Identifier</em><code>.</code><em>view:Identifier</em><code>(</code><em>heap:Identifier</em><code>);</code>
</div>

<p>The variable <em>stdlib</em> must match the first parameter of
the <a href="">module declaration</a> and the variable <em>heap</em>
must match the third. The identifier <em>view</em> must be one of the
standard <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a>
type names. The global variable <em>x</em> is stored in
the <a href="">global environment</a> with type <code>imm</code>
<em>view</em>.

<h2>Validation Rules</h2>

<p>To ensure that a JavaScript function is a proper asm.js module, it
must first be statically validated. This section specifies the
validation rules. The rules operate on JavaScript abstract syntax,
i.e., the output of a JavaScript parser. The non-terminals refer to
parse nodes defined by productions in
the <a href="http://ecma-international.org/ecma-262/5.1/#sec-A">ECMAScript
grammar</a>, but note that the asm.js validator only accepts a subset
of legal JavaScript programs.

<h3>Modules</h3>

<p>An asm.js module is a <em>FunctionDeclaration</em>
or <em>FunctionExpression</em> node with up to three optional
parameters:

<!--
<div class="example">
<code>function</code> <em>Identifier<sub>opt</sub></em><code>() { "use asm";</code> <em>decl:SourceElement</em>&hellip; <em>ReturnStatement</em> <code>}</code><br>
<code>function</code> <em>Identifier<sub>opt</sub></em><code>(</code><em>stdlib:Identifier</em><code>) { "use asm";</code> <em>decl:SourceElement</em>&hellip; <em>ReturnStatement</em> <code>}</code><br>
<code>function</code> <em>Identifier<sub>opt</sub></em><code>(</code><em>stdlib:Identifier</em><code>,</code> <em>foreign:Identifier</em><code>) { "use asm";</code> <em>decl:SourceElement</em>&hellip; <em>ReturnStatement</em> <code>}</code><br>
</div>
-->

<div class="example">
<code>function</code> <em>f:Identifier<sub>opt</sub></em><code>(</code><span class="meta">(</span><em>stdlib:Identifier</em><code><span class="meta">(</span>,</code> <em>foreign:Identifier</em><span class="meta">(</span><code>,</code> <em>heap:Identifier</em><span class="meta">)</span><sub><em>opt</em></sub><span class="meta">)</span><sub><em>opt</em></sub><span class="meta">)</span><sub><em>opt</em></sub><code>) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;"use asm";</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><em>var:VariableStatement</em> <span class="meta">|</span> <em>fun:FunctionDeclaration</em><span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>exports:ReturnStatement</em><br>
<code>}</code>
</div>

<p>A module is valid if:

<ul>
<li><em>f</em>, <em>stdlib</em>, <em>foreign</em>, <em>heap</em>, and
the <em>var</em> and <em>fun</em> variables are all mutually distinct;
<li>the global environment &Delta; is constructed from
the <a href="">global variable type annotations</a> in
the <em>var</em> declarations and the <a href="">function type
annotations</a> in the <em>fun</em> declarations;
<li>each <em>fun</em> declaration is valid in &Delta;;
<li>and <em>exports</em> is valid in &Delta;.
</ul>

<h3>Export Declarations</h3>

<p>An asm.js module's export declaration is a <em>ReturnStatement</em>
returning either a single asm.js function or an object literal
exporting multiple asm.js functions.

<p>An export declaration node

<div class="example">
<code>return</code> <code>{</code> <span class="meta">(</span><em>x:Identifier</em> <code>:</code> <em>f:Identifier</em><span class="meta">)</span>&hellip; <code> };</code>
</div>

<p>is valid if for each <em>f</em>, &Delta;(f) = <code>imm</code>
&gamma; where &gamma; is a function type (&sigma;,&hellip;) &rarr;
&tau;.

<p>An export declaration node

<div class="example">
<code>return</code> <em>f:Identifier</em><code>;</code>
</div>

<p>is valid if &Delta;(f) = <code>imm</code> &gamma; where &gamma; is
a function type (&sigma;,&hellip;) &rarr; &tau;.

<h3>Function Declarations</h3>

<!--
<div class="example">
<em>SourceElement</em> : <code>function</code> <em>Identifier</em><code>(</code><span class="seq"><em>x</em></span><code>) {</code> <span class="seq"><em>x</em> <code>=</code> <em>AsmAnnotation<sub>x</sub></em><code>;</code></span> <em>AsmFunctionBody</em> <code>}</code>
</div>

<div class="example">
<em>SourceElement</em> : <code>function</code> <em>Identifier</em><code>(</code><em>FormalParameterList<sub>opt</sub></em><code>) {</code> <em>AsmAnnotationList<sub>opt</sub></em> <em>List</em>&lt;<em>VariableStatement</em>&gt; <em>List</em>&lt;<em>Statement</em>&gt; <code>}</code>
</div>
-->

<p>An asm.js function declaration is a <em>FunctionDeclaration</em> node

<div class="example">
<code>function</code> <em>f:Identifier</em><code>(</code><em>x:Identifier</em>&hellip;<code>) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><em>x:Identifier</em> <code>=</code> <em>AssignmentExpression</em><code>;</code><span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><code>var </code><span class="meta">(</span><em>y:Identifier</em> <code>=</code> <em>n:NumericLiteral</em><span class="meta">)</span><code>,</code>&hellip;<span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>body:Statement</em>&hellip;<br>
<code>}</code>
</div>

<p>A function declaration is valid if:

<ul>
<li>&Delta;(f) = <code>imm</code> (&sigma;,&hellip;) &rarr; &tau;;
<li>the <em>x</em> and <em>y</em> variables are all mutually distinct;
<li>the variable environment &Gamma; is constructed by mapping each
parameter <em>x</em> to its <a href="">parameter type annotation</a>
and each local variable <em>y</em> to its <a href="">variable type
annotation</a>;
<li>each <code>body</code> statement is valid in &Delta; and &Gamma;
with expected return type &tau;.
</ul>

<h3>Statements</h3>

<p>Each statement is validated in the context of a <span>global
environment</span> &Delta;, a <span>variable environment</span>
&Gamma;, and an expected return type &tau;. Unless otherwise
explicitly stated, a recursive validation of a subterm uses the same
context as its containing term.

<h4>Block</h4>

<p>A <em>Block</em> statement node

<div class="example">
<code>{</code> <em>stmt:Statement</em>&hellip; <code>}</code>
</div>

<p>is valid if each <em>stmt</em> is valid.

<h4>ExpressionStatement</h4>

<p>An <em>ExpressionStatement</em> node

<div class="example">
<em>expr:Expression</em> <code>;</code>
</div>

<p>is valid if <em>expr</em> is valid.

<h4>EmptyStatement</h3>

<p>An <em>EmptyStatement</em> node is always valid.

<h4>IfStatement</h4>

<p>An <em>IfStatement</em> node

<div class="example">
<code>if (</code> <em>expr:Expression</em> <code>)</code> <em>stmt1:Statement</em> <code>else</code> <em>stmt2:Statement</em>
</div>

<p>is valid if <em>expr</em> validates as a subtype
of <code>int</code> and <em>stmt1</em> and <em>stmt2</em> are both
valid.

<p>An <em>IfStatement</em> node

<div class="example">
<code>if (</code> <em>expr:Expression</em> <code>)</code> <em>stmt:Statement</em>
</div>

<p>is valid if <em>expr</em> validates as a subtype
of <code>int</code> and <em>stmt</em> is valid.

<h4>ReturnStatement</h4>

<p>A <em>ReturnStatement</em> node

<div class="example">
<code>return</code> <em>expr:Expression</em> <code>;</code>
</div>

<p>is valid if <em>expr</em> validates as a subtype of the expected
return type &tau;.

<p>A <em>ReturnStatement</em> node

<div class="example">
<code>return ;</code>
</div>

<p>is valid if the expected return type &tau; is <code>void</code>.


<h4>IterationStatement</h4>

<p>An <em>IterationStatement</em> node

<div class="example">
<code>while (</code> <em>expr:Expression</em> <code>)</code> <em>stmt:Statement</em>
</div>

<p>is valid if <em>expr</em> validates as a subtype
of <code>int</code> and <em>stmt</em> is valid.

<p>An <em>IterationStatement</em> node

<div class="example">
<code>do</code> <em>stmt:Statement</em> <code>while (</code> <em>expr:Expression</em> <code>) ;</code>
</div>

<p>is valid if <em>stmt</em> is valid and <em>expr</em> validates as a
subtype of <code>int</code>.

<p>An <em>IterationStatement</em> node

<div class="example">
<code>for (</code> <em>init:ExpressionNoIn<sub>opt</sub></em> <code>;</code> <em>test:Expression<sub>opt</sub></em> <code>;</code> <em>update:Expression<sub>opt</sub></em> <code>)</code> <em>body:Statement</em>
</div>

<p>is valid if <em>init</em> validates (if present),
<em>test</em> validates as a subtype of <code>int</code> (if
present), <em>update</em> validates (if present), and <em>body</em> is
valid.

<h4>BreakStatement</h4>

<p>A <em>BreakStatement</em> node

<div class="example">
<code>break</code> <em>Identifier<sub>opt</sub></em> <code>;</code>
</div>

<p>is always valid.

<h4>ContinueStatement</h4>

<p>A <em>ContinueStatement</em> node

<div class="example">
<code>continue</code> <em>Identifier<sub>opt</sub></em> <code>;</code>
</div>

<p>is always valid.

<h4>LabelledStatement</h4>

<p>A <em>LabelledStatement</em> node

<div class="example">
<em>Identifier</em> <code>:</code> <em>body:Statement</em>
</div>

<p>is valid if <em>body</em> is valid.

<h4>SwitchStatement</h4>

<p>A <em>SwitchStatement</em> node

<div class="example">
<code>switch (</code> <em>test:Expression</em> <code>)</code> <code>{</code> <em>case:CaseClause</em>&hellip; <em>default:DefaultClause<sub>opt</sub></em> <code>}</code>
</div>

<p>is valid if <em>test</em> validates as a subtype of &sigma; where
&sigma; is <code>signed</code> or <code>unsigned</code>,
each <em>case</em> validates with expected case type &sigma;,
and <em>default</em> is valid.

<!--
<h3>Statement Lists</h3>

<p>Just like statements, statement lists are validated in the context
of a <span>global environment</span> &Delta;, a <span>variable
environment</span> &Gamma;, and an expected return type &tau;. Unless
otherwise explicitly stated, a recursive validation of a subterm uses
the same context as its containing term.

<p>A <em>StatementList</em>

<div class="example">
<em>StatementList</em> : <em>StatementList<sub>opt</sub></em> <em>Statement</em>
</div>

<p>is valid if the <em>StatementList</em> (if any) is valid and the <em>Statement</em> is valid.
-->


<h3>Switch Cases</h3>

<p>Cases in a <code>switch</code> block are validated in the context
of a <span>global environment</span> &Delta;, a <span>variable
environment</span> &Gamma;, an expected return type &tau;, and an
expected case type &sigma;. Unless otherwise explicitly stated, a
recursive validation of a subterm uses the same context as its
containing term.

<!--
<h4>CaseBlock</h4>

<p>A <em>CaseBlock</em> node

<div class="example">
<code>{</code> <em>CaseClause</em>&hellip; <em>DefaultClause<sub>opt</sub></em> <code>}</code>
</div>

<p>is valid if the <em>CaseClause</em> list is valid and the <em>DefaultClause</em> (if any) is valid.
-->

<!--
<h4>CaseClauses</h4>

<p>A <em>CaseClauses</em> list

<div class="example">
<em>CaseClauses</em> : <em>CaseClauses<sub>opt</sub></em> <em>CaseClause</em>
</div>

<p>is valid if the <em>CaseClauses</em> (if any) are valid and the <em>CaseClause</em> is valid.
-->

<h4>CaseClause</h4>

<p>A <em>CaseClause</em> node

<div class="example">
<code>case</code> <em>n:NumericLiteral</em> <code>:</code> <em>stmt:Statement</em>&hellip;
</div>

<p>is valid if <em>n</em> validates as a subtype of the expected case
case type &sigma; and <em>stmt</em> list is valid.

<h4>DefaultClause</h4>

<p>A <em>DefaultClause</em> node

<div class="example">
<code>default :</code> <em>stmt:Statement</em>&hellip;
</div>

<p>is valid if each <em>stmt</em> is valid.


<h3>Expressions</h3>

<h4>NumericLiteral</h4>

<p>For a <em>NumericLiteral</em> node:

<ul>
<li>if the source contains a <code>.</code> character, the expression
validates as type <code>double</code>;
<li>if the source does not contain a <code>.</code> character and its
numeric value is in the range [-2<sup>31</sup>, 0), the expression
validates as type <code>signed</code>;
<li>if the source does not contain a <code>.</code> character and its
numeric value is in the range [0, 2<sup>31</sup>), the expression
validates as type <code>fixnum</code>;
<li>if the source does not contain a <code>.</code> character and its
numeric value is in the range [2<sup>31</sup>, 2<sup>32</sup>), the
expression validates as type <code>unsigned</code>.
</ul>

<p>Note that integer literals outside the range [-2<sup>31</sup>,
2<sup>32</sup>) are invalid, i.e., fail to validate.

<h4>Identifier</h4>

<p>An <em>Identifier</em> node

<div class="example">
<em>x:Identifier</em>
</div>

<p>validates as <em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>).

<h4>MemberExpression</h4>

<p>A <em>MemberExpression</em> node

<div class="example">
<em>x:Identifier</em><code>[</code><em>n:NumericLiteral</em><code>]</code><br>
<em>x:Identifier</em><code>[</code><em>expr:Expression</em><code>]</code><br>
<em>x:Identifier</em><code>[</code><em>expr:Expression</em> <code>&gt;&gt;</code> <em>n:NumericLiteral</em><code>]</code><br>
</div>
<p>is valid if...

<h4>AssignmentExpression</h4>

<p>An <em>AssignmentExpression</em> node

<div class="example">
<em>x:Identifier</em> <code>=</code> <em>expr:AssignmentExpression</em>
</div>

<p>validates as type &tau; if the nested <em>AssignmentExpression</em>
validates as type &tau; and one of the following two conditions holds:

<ul>
<li><em>x</em> is bound in &Gamma; as a supertype of &tau;; or
<li><em>x</em> is not bound in &Gamma; and is bound to a mutable supertype of &tau; in &Delta;.
</ul>

<p>An <em>AssignmentExpression</em> node

<div class="example">
<em>lhs:MemberExpression</em> <code>=</code> <em>rhs:AssignmentExpression</em>
</div>

<!--
<div class="example">
<em>x:Identifier</em><code>[</code><em>n:NumericLiteral</em><code>] = </code><em>rhs:AssignmentExpression</em><br>
<em>x:Identifier</em><code>[</code><em>expr:Expression</em><code>] = </code><em>rhs:AssignmentExpression</em><br>
<em>x:Identifier</em><code>[</code><em>expr:Expression</em> <code>&gt;&gt;</code> <em>n:NumericLiteral</em><code>] = </code><em>rhs:AssignmentExpression</em><br>
</div>
-->

<h4>CallExpression</h4>

<p>A <em>CallExpression</em> node

<div class="example">
<em>x:Identifier</em><code>(</code><em>arg:Expression</em><code>,</code>&hellip;<code>)</code>
</div>

<h4>UnaryExpression</h4>

<p>A <em>UnaryExpression</em> node

<div class="example">
<code>+</code><em>arg:UnaryExpression</em><br>
<code>-</code><em>arg:UnaryExpression</em><br>
<code>~</code><em>arg:UnaryExpression</em><br>
<code>~~</code><em>arg:UnaryExpression</em>
</div>

<h4>MultiplicativeExpression</h4>

<p>A <em>MultiplicativeExpression</em> node

<div class="example">
<em>lhs:MultiplicativeExpression</em> <code>*</code> <em>rhs:UnaryExpression</em><br>
<em>lhs:MultiplicativeExpression</em> <code>/</code> <em>rhs:UnaryExpression</em><br>
<em>lhs:MultiplicativeExpression</em> <code>%</code> <em>rhs:UnaryExpression</em><br>
</div>

<h4>AdditiveExpression</h4>

<div class="example">
<em>lhs:AdditiveExpression</em> <code>+</code> <em>rhs:MultiplicativeExpression</em><br>
<em>lhs:AdditiveExpression</em> <code>-</code> <em>rhs:MultiplicativeExpression</em>
</div>

<h4>ShiftExpression</h4>

<div class="example">
<em>lhs:ShiftExpression</em> <code>&lt;&lt;</code> <em>rhs:AdditiveExpression</em><br>
<em>lhs:ShiftExpression</em> <code>&gt;&gt;</code> <em>rhs:AdditiveExpression</em><br>
<em>lhs:ShiftExpression</em> <code>&gt;&gt;&gt;</code> <em>rhs:AdditiveExpression</em><br>
</div>

<h4>RelationalExpression</h4>

<div class="example">
<em>lhs:RelationalExpression</em> <code>&lt;</code> <em>rhs:ShiftExpression</em><br>
<em>lhs:RelationalExpression</em> <code>&gt;</code> <em>rhs:ShiftExpression</em><br>
<em>lhs:RelationalExpression</em> <code>&lt;=</code> <em>rhs:ShiftExpression</em><br>
<em>lhs:RelationalExpression</em> <code>&gt;=</code> <em>rhs:ShiftExpression</em><br>
</div>

<h4>EqualityExpression</h4>

<div class="example">
<em>lhs:EqualityExpression</em> <code>==</code> <em>rhs:RelationalExpression</em><br>
<em>lhs:EqualityExpression</em> <code>!=</code> <em>rhs:RelationalExpression</em>
</div>

<h4>BitwiseANDExpression</h4>

<div class="example">
<em>lhs:BitwiseANDExpression</em> <code>&amp;</code> <em>rhs:EqualityExpression</em><br>
</div>

<h4>BitwiseXORExpression</h4>

<div class="example">
<em>lhs:BitwiseXORExpression</em> <code>^</code> <em>rhs:BitwiseANDExpression</em><br>
</div>

<h4>BitwiseORExpression</h4>

<div class="example">
<em>lhs:BitwiseORExpression</em> <code>|</code> <em>rhs:BitwiseXORExpression</em><br>
</div>

<h4>ConditionalExpression</h4>

<div class="example">
<em>test:LogicalORExpression</em> <code>?</code> <em>cons:AssignmentExpression</em> <code>:</code> <em>alt:AssignmentExpression</em>
</div>

<h4>Parenthesized Expression</h4>

<div class="example">
<code>(</code> <em>expr:Expression</em> <code>)</code>
</div>

<h2>Linking</h2>

<p>TODO

<h2>Operators</h2>

<h3>Unary Operators</h3>

<table>
<tbody>
<tr>
  <th>Unary Operator</th>
  <th>Type</th>
</tr>
<tr>
  <td><code>+</code></td>
  <td>
    (<code>signed</code>) &rarr; <code>double</code> &and;<br>
    (<code>unsigned</code>) &rarr; <code>double</code> &and;<br>
    (<code>doublish</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td><code>-</code></td>
  <td>
    (<code>int</code>) &rarr; <code>intish</code> &and;<br>
    (<code>doublish</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td><code>~</code></td>
  <td>(<code>intish</code>) &rarr; <code>signed</code></td>
</tr>
</tbody>
</table>

<h3>Binary Operators</h3>

<table>
<tbody>
<tr>
  <th>Binary Operator</th>
  <th>Type</th>
</tr>
<tr>
  <td><code>+</code></td>
  <td>(<code>double</code>, <code>double</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td><code>-</code></td>
  <td>(<code>doublish</code>, <code>doublish</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td><code>*</code></td>
  <td>(<code>doublish</code>, <code>doublish</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td><code>/</code></td>
  <td>
    (<code>signed</code>, <code>signed</code>) &rarr; <code>intish</code> &and;<br>
    (<code>unsigned</code>, <code>unsigned</code>) &rarr; <code>intish</code> &and;<br>
    (<code>doublish</code>, <code>doublish</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td><code>%</code></td>
  <td>
    (<code>signed</code>, <code>signed</code>) &rarr; <code>int</code> &and;<br>
    (<code>unsigned</code>, <code>unsigned</code>) &rarr; <code>int</code> &and;<br>
    (<code>doublish</code>, <code>doublish</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td><code>|</code>, <code>&amp;</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
  <td>(<code>intish</code>, <code>intish</code>) &rarr; <code>signed</code></td>
</tr>
<tr>
  <td><code>&gt;&gt;&gt;</code></td>
  <td>(<code>intish</code>, <code>intish</code>) &rarr; <code>unsigned</code></td>
</tr>
<tr>
  <td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code></td>
  <td>
    (<code>signed</code>, <code>signed</code>) &rarr; <code>int</code> &and;<br>
    (<code>unsigned</code>, <code>unsigned</code>) &rarr; <code>int</code> &and;<br>
    (<code>double</code>, <code>double</code>) &rarr; <code>int</code>
  </td>
</tr>
</tbody>
</table>

<h2>Standard Library</h2>

<table>
<tbody>
<tr>
  <th>Standard Library</th>
  <th>Type</th>
</tr>
<tr>
  <td>
    <code>Infinity</code><br>
    <code>NaN</code>
  </td>
  <td><code>double</code></td>
</tr>
<tr>
  <td>
    <code>Math.acos</code><br>
    <code>Math.asin</code><br>
    <code>Math.atan</code><br>
    <code>Math.cos</code><br>
    <code>Math.sin</code><br>
    <code>Math.tan</code><br>
    <code>Math.ceil</code><br>
    <code>Math.floor</code><br>
    <code>Math.exp</code><br>
    <code>Math.log</code><br>
    <code>Math.sqrt</code>
  </td>
  <td>(<code>doublish</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td><code>Math.abs</code></td>
  <td>
    (<code>signed</code>) &rarr; <code>unsigned</code> &and;<br>
    (<code>doublish</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td>
    <code>Math.atan2</code><br>
    <code>Math.pow</code>
  </td>
  <td>(<code>doublish</code>, <code>doublish</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td><code>Math.imul</code></td>
  <td>(<code>int</code>, <code>int</code>) &rarr; <code>signed</code></td>
</tr>
<tr>
  <td>
    <code>Math.E</code><br>
    <code>Math.LN10</code><br>
    <code>Math.LN2</code><br>
    <code>Math.LOG2E</code><br>
    <code>Math.LOG10E</code><br>
    <code>Math.PI</code><br>
    <code>Math.SQRT1_2</code><br>
    <code>Math.SQRT2</code><br>
  </td>
  <td><code>double</code></td>
</tr>
</tbody>
</table>

<p>TODO

<h2 class="no-num">Acknowledgements</h2>

<p>Thanks to Martin Best, Brendan Eich, Andrew McCreight, Vlad Vuki&cacute;evi&cacute;, ...
</body>
</html>
