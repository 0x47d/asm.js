\documentclass{article}

\usepackage{mathpartir}
\usepackage{amssymb}

\newcommand{\ternary}[3]{{#1}\ \mathjs{?}\ {#2}\ \mathjs{:}\ {#3}}
\newcommand{\funcall}[2]{{#1}\mathjs{(}{#2}\mathjs{)}}
\newcommand{\paren}[1]{\mathjs{(}{#1}\mathjs{)}}
\newcommand{\dom}{\mathit{dom}}
\newcommand{\type}{\mathit{type}}
\newcommand{\funty}[2]{({#1}) \rightarrow {#2}}
\newcommand{\seq}[1]{\overline{{#1}}}
\newcommand{\mathjs}[1]{\mbox{\texttt{{#1}}}}
\newcommand{\mathjssm}[1]{\mbox{\texttt{\scriptsize {#1}}}}
\newcommand{\return}[1]{\mathjs{return }{#1}\mathjs{;}}
\newcommand{\fun}[3]{\mathjs{function }{#1}\mathjs{(}{#2}\mathjs{) \char123{} }{#3}\mathjs{ \char125{}}}
\newcommand{\afun}[2]{\mathjs{function}\mathjs{(}{#1}\mathjs{) \char123{} }{#2}\mathjs{ \char125{}}}
\newcommand{\var}[1]{\mathjs{var }{#1}\mathjs{;}}
\newcommand{\rel}[1]{\scriptsize [\textsc{#1}]}
\newcommand\defeq{\stackrel{\mbox{\tiny def}}{=}}
\newcommand{\while}[2]{\mathjs{while (}{#1}\mathjs{) }{#2}}
\newcommand{\dowhile}[2]{\mathjs{do }{#1}\mathjs{ while (}{#2}\mathjs{);}}
\newcommand{\for}[4]{\mathjs{for (}{#1}\mathjs{; }{#2}\mathjs{; }{#3}\mathjs{) }{#4}}
\newcommand{\switch}[2]{\mathjs{switch (}{#1}\mathjs{) \char123{} }{#2}\mathjs{ \char125{}}}
\newcommand{\switchdef}[3]{\mathjs{switch (}{#1}\mathjs{) \char123{} }{#2}\mathjs{ default:}\,{#3}\mathjs{ \char125{}}}
\newcommand{\brk}{\mathjs{break;}}
\newcommand{\brkl}[1]{\mathjs{break }{#1}\mathjs{;}}
\newcommand{\cont}{\mathjs{continue;}}
\newcommand{\contl}[1]{\mathjs{continue }{#1}\mathjs{;}}
\newcommand{\lab}[2]{{#1}\mathjs{:}\,{#2}}
\newcommand{\ifthen}[2]{\mathjs{if (}{#1}\mathjs{) }{#2}}
\newcommand{\ifthenelse}[3]{\mathjs{if (}{#1}\mathjs{) }{#2}\mathjs{ else }{#3}}
\newcommand{\block}[1]{\mathjs{\char123{} }{#1}\mathjs{ \char125{}}}
\newcommand{\ok}{\mathrm{\mathbf{ok}}}
\newcommand{\rulebreak}{\vspace{.1in}\\}
\newcommand{\bit}{\mathtt{bit}}
\newcommand{\unsigned}{\mathtt{unsigned}}
\newcommand{\intsm}{\mathjssm{int}}
\newcommand{\doublesm}{\mathjssm{double}}
\newcommand{\signed}{\mathtt{signed}}
\newcommand{\constant}{\mathtt{constant}}
\newcommand{\double}{\mathtt{double}}
\newcommand{\arr}[2]{\mathtt{array}^{#1}_{#2}}
\newcommand{\extern}{\mathtt{extern}}
\newcommand{\unk}{\mathtt{unknown}}
\newcommand{\str}{\mathtt{string}}
\newcommand{\undef}{\mathtt{undefined}}
\newcommand{\void}{\mathtt{void}}
\newcommand{\nul}{\mathtt{null}}
\newcommand{\num}{\mathtt{number}}
\newcommand{\obj}{\mathtt{object}}
\newcommand{\mustret}{\mathsf{return}}
\newcommand{\seqcomp}{\mathrel{;}}
\newcommand{\getprop}[2]{{#1}\mathjs{[}{#2}\mathjs{]}}
\newcommand{\getpropsm}[2]{{#1}\mathjssm{[}{#2}\mathjssm{]}}
\newcommand{\longlong}[2]{\mathjs{[}{#1},{#2}\mathjs{]}}
\newcommand{\toint}[1]{\mathjs{\~{}\~{}}{#1}}
\newcommand{\todouble}[1]{\mathjs{+}{#1}}
\renewcommand{\int}{\mathtt{int}}
\newcommand{\dword}{\mathtt{bits64}}
\newcommand{\function}{\mathtt{function}}
\newcommand{\union}[2]{{#1}\mathrel{|}{#2}}
\newcommand{\boolish}{\mathtt{boolish}}
\newcommand{\floor}{\mathtt{floor}}
\newcommand{\imul}{\mathtt{imul}}
\newcommand{\intish}{\mathtt{intish}}

\newcommand{\progjudge}[1]{\vdash {#1}\ \ok}
\newcommand{\impjudge}[4]{{#1};{#2};{#3} \vdash {#4}\ \ok}
\newcommand{\fnjudge}[2]{{#1} \vdash {#2}\ \ok}
\newcommand{\expjudge}[2]{{#1} \vdash {#2}\ \ok}
\newcommand{\stmtjudge}[5]{{#1};{#2} \vdash {#3} : {#4} / {#5}}
\newcommand{\exprjudge}[4]{{#1};{#2} \vdash {#3} : {#4}}

\begin{document}

\title{\texttt{asm.js}}
\author{Dave Herman, Luke Wagner, and Alon Zakai}
\maketitle

\section{Abstract syntax}

\[
\begin{array}{rcl}
b, e, f, g, x, y, z               & \in & \mathit{Identifier} \\
\mathtt{arguments}, \mathtt{eval} & \not\in & \mathit{Identifier} \\
\end{array}
\]

\[
\begin{array}{rcl}
P               & ::= & \fun{[g]}{[e[, b]]}{\mathjs{"use asm"; } \seq{\mathit{imp}_x}\ \seq{\mathit{fn}_f}\ \seq{\var{\seq{y \mathjs{ = } v}}}\ \mathit{exp}} \\
\mathit{imp}_x  & ::= & \var{x \mathjs{ = } e\mathjs{.}y} \\
                &  |  & \var{x \mathjs{ = } \mathjs{new }\funcall{e\mathjs{.}y}{b}} \\
\mathit{exp}    & ::= & \return{f} \\
                &  |  & \return{\mathjs{\char123{} } \seq{x \mathjs{:} f} \mathjs{ \char125{}}} \\
\mathit{fn}_f   & ::= & \fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \seq{\var{\seq{y\mathjs{ = }v}}}\ \mathit{ss}} \\
\end{array}
\]

\[
\begin{array}{rcl}
s & ::= & \block{\mathit{ss}} \\
  &  |  & e\mathjs{;} \\
  &  |  & \mathjs{;} \\
  &  |  & \ifthen{e}{s} \\
  &  |  & \ifthenelse{e}{s}{s} \\
  &  |  & \return{e} \\
  &  |  & \while{e}{s} \\
  &  |  & \dowhile{s}{e} \\
  &  |  & \for{[e]}{[e]}{[e]}{s} \\
  &  |  & \switch{e}{\seq{c}} \\
  &  |  & \switch{e}{\seq{c}\ d} \\
  &  |  & \brk \\
  &  |  & \brkl{\mathit{lab}} \\
  &  |  & \cont \\
  &  |  & \contl{\mathit{lab}} \\
  &  |  & \lab{\mathit{lab}}{s} \\
\\
\mathit{ss} & ::= & \seq{s} \\
\\
c & ::= & \mathjs{case }v\mathjs{:}\,\mathit{ss} \\
d & ::= & \mathjs{default:}\,\mathit{ss} \\
\mathit{cd} & ::= & c ~|~ d \\
\end{array}
\]

\[
\kappa_x ::= \toint{x} ~|~ \todouble{x} ~|~ x\mathjs{|0} ~|~ x\mathjs{>>>0} \\
\]

\[
\begin{array}{rcl}
v & ::= & r ~|~ n \\
\\
e & ::= & v \\
  &  |  & \mathit{lval} \\
  &  |  & \mathit{lval}\mathjs{ = }e \\
  &  |  & \funcall{f}{\seq{e}} \\
  &  |  & \mathit{unop}\ e \\
  &  |  & e\ \mathit{binop}\ e \\
  &  |  & \ternary{e}{e}{e} \\
  &  |  & \paren{\seq{e}} \\
\\
\mathit{unop} & ::= & \mathjs{+} ~|~ \mathjs{\~{}} ~|~ \mathjs{!} \\
\\
\mathit{binop} & ::= & \mathjs{+} ~|~ \mathjs{-} ~|~ \mathjs{*} ~|~ \mathjs{/} ~|~ \mathjs{\%} \\
               &  |  & \mathjs{|} ~|~ \mathjs{\&} ~|~ \mathjs{\^{}} ~|~ \mathjs{<<} ~|~ \mathjs{>>} ~|~ \mathjs{>>>} \\
               &  |  & \mathjs{<} ~|~ \mathjs{<=} ~|~ \mathjs{>} ~|~ \mathjs{>=} ~|~ \mathjs{!=} ~|~ \mathjs{==} \\
\mathit{lval} & ::= & x ~|~ \getprop{x}{\paren{e\mathjs{ \& }m}\mathjs{ >> }n} \\
\end{array}
\]

\section{Type rules}

\[
\begin{array}{rcl}
\sigma, \tau & ::= & \bit ~|~ \double ~|~ \int ~|~ \signed ~|~ \unsigned ~|~ \boolish ~|~ \intish ~|~ \void ~|~ \unk \\
\rho & ::= & \tau ~|~ \arr{n}{\tau} ~|~ \imul ~|~ \function ~|~ \funty{\seq{\sigma}}{\tau} \\
\omega & ::= & (\funty{\seq{\sigma}}{\tau}) \land \ldots \land (\funty{\seq{\sigma'}}{\tau'}) \\
\end{array}
\]

\[
\begin{array}{rcl}
\ell        & ::= & \mathit{lab} ~|~ \epsilon \\
L           & ::= & \{ \seq{\ell} \} \\
\varepsilon & ::= & L ~|~ \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
L                       \seqcomp L'       & = & L \cup L' \\
\emptyset               \seqcomp \mustret & = & \mustret \\
\{ \ell, \seq{\ell'} \} \seqcomp \mustret & = & \{ \ell, \seq{\ell'} \} \\
\mustret                \seqcomp L        & = & \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
L        \cup \mustret & = & L \\
\mustret \cup L        & = & L \\
\mustret \cup \mustret & = & \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
\type(\toint{X})      & = & \int \\
\type(\todouble{X})   & = & \double \\
\type(n)              & = & \int \\
\type(r)              & = & \double \\
\type(X\mathjs{|0})   & = & \signed \\
\type(X\mathjs{>>>0}) & = & \unsigned \\
\end{array}
\]

%% NOTE: pure pointers will not be jsval

\[
\begin{array}{rcl}
\constant                                                                           & <: & \signed, \unsigned \\
\signed, \unsigned                                                                  & <: & \int, \extern \\
\bit, \int                                                                          & <: & \boolish \\
\double                                                                             & <: & \extern \\
\unk, \int                                                                          & <: & \intish \\
\end{array}
\]

\[
\begin{array}{rcl}
M(\imul) & : & \imul \\
M(\mathtt{ceil}), M(\mathtt{sin}), M(\mathtt{cos}) & : & \funty{\double}{\double} \\
\end{array}
\]

\[
\begin{array}{rcl}
A(\mathtt{Uint8Array}), A(\mathtt{Int8Array})   & = & \arr{8}{\intsm} \\
A(\mathtt{Uint16Array}), A(\mathtt{Int16Array}) & = & \arr{16}{\intsm} \\
A(\mathtt{Uint32Array}), A(\mathtt{Int32Array}) & = & \arr{32}{\intsm} \\
A(\mathtt{Float32Array})                        & = & \arr{32}{\doublesm} \\
A(\mathtt{Float64Array})                        & = & \arr{64}{\doublesm} \\
\end{array}
\]

\[
\begin{array}{rcc@{\ }l}
\mathjs{+}, \mathjs{-}
                 & : &       & \funty{\double, \double}{\double} \\
                 &   & \land & \funty{\int, \int}{\intish} \\
\mathjs{*}       & : &       & \funty{\double, \double}{\double} \\
\mathjs{/}, \mathjs{\%}
                 & : &       & \funty{\double, \double}{\double} \\
                 &   & \land & \funty{\signed, \signed}{\intish}  \\
                 &   & \land & \funty{\unsigned, \unsigned}{\intish} \\
\\
\mathjs{|}, \mathjs{\&}, \mathjs{\^{}}, \mathjs{<<}, \mathjs{>>}
                 & : &       & \funty{\intish, \intish}{\signed} \\
\mathjs{>>>}     & : &       & \funty{\intish, \intish}{\unsigned} \\
\\
\mathjs{<}, \mathjs{<=}, \mathjs{>}, \mathjs{>=}, \mathjs{==}, \mathjs{!=}
                 & : &       & \funty{\signed, \signed}{\bit} \\
                 &   & \land & \funty{\unsigned, \unsigned}{\bit} \\
                 &   & \land & \funty{\double, \double}{\bit} \\
\\
\mathjs{+}       & : &       & \funty{\intish}{\double} \\
\mathjs{\~{}}    & : &       & \funty{\intish}{\signed} \\
\mathjs{!}       & : &       & \funty{\boolish}{\bit} \\
\end{array}
\]

\[
\begin{array}{rcl}
\Delta & ::= & \{ \seq{x : \rho} \} \\
\Gamma & ::= & \{ \seq{x : \tau} \} \\
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Program checking} & \hfil \fbox{$\progjudge{P}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Program}]
  {\seq{x}, \seq{y}, \seq{f}, [g], [e], [b]\ \mbox{distinct} \\
   \forall y . \Delta(y) = \type(v) \\\\
   \forall i . \impjudge{[e]}{[b]}{\Delta}{\mathit{imp}_x} \\
   \forall i . \fnjudge{\Delta}{\mathit{fn}_f} \\
   \forall i . \expjudge{\Delta}{\mathit{exp}}}
  {\progjudge{\fun{[g]}{[e[, b]]}{\mathjs{"use asm";}\ \seq{\mathit{imp}_x}\ \seq{\mathit{fn}_f}\ \seq{\var{\seq{y \mathjs{ = } v}}}\ \mathit{exp}}}}
\end{array}
}
\\ \\
\mbox{Import checking} & \hfil \fbox{$\impjudge{[e]}{[b]}{\Delta}{\mathit{imp}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-ImportStd}]
  {\Delta(x) = M(y)}
  {\impjudge{e}{[b]}{\Delta}{\var{x \mathjs{ = } e\mathjs{.}y}}}
\qquad
\inferrule* [lab=\rel{T-ImportFFI}]
  {y \not\in\dom(M), \dom(A) \\
   \Delta(x) = \function}
  {\impjudge{e}{[b]}{\Delta}{\var{x \mathjs{ = } e\mathjs{.}y}}}
\\ \\
\inferrule* [lab=\rel{T-NewView}]
  {\Delta(x) = \arr{n}{A(y)}}
  {\impjudge{e}{b}{\Delta}{\var{x \mathjs{ = new } e\mathjs{.}y(b)}}}
\end{array}
}
\\ \\
\mbox{Function checking} & \hfil \fbox{$\fnjudge{\Delta}{\mathit{fn}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Function}]
  {\seq{x}, \seq{y}\ \mbox{distinct} \\
   \Delta(f) = \funty{\seq{\sigma}}{\tau} \\
   \seq{\sigma} = \seq{\type(\kappa_x)} \\
   \tau \not= \void \\\\
   \stmtjudge{\Delta}{\{ \seq{x : \sigma}, \seq{y : \type(v)} \}}{\mathit{ss}}{\tau}{\mustret}}
  {\fnjudge{\Delta}{\fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \seq{\var{\seq{y\mathjs{ = }v}}}\ \mathit{ss}}}}
\\ \\
\inferrule* [lab=\rel{T-VoidFunction}]
  {\seq{x}, \seq{y}\ \mbox{distinct} \\
   \Delta(f) = \funty{\seq{\sigma}}{\void} \\
   \seq{\sigma} = \seq{\type(\kappa_x)} \\\\
   \stmtjudge{\Delta}{\{ \seq{x : \sigma}, \seq{y : \type(v)} \}}{\mathit{ss}}{\void}{\varepsilon}}
  {\fnjudge{\Delta}{\fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \seq{\var{\seq{y\mathjs{ = }v}}}\ \mathit{ss}}}}
\end{array}
}
\\ \\
\mbox{Export checking} & \hfil \fbox{$\expjudge{\Delta}{\mathit{exp}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Singleton}]
  {\Delta(f) = \funty{\seq{\sigma}}{\tau} \\
   \tau <: \extern }
  {\expjudge{\Delta}{\return{f}}}
\qquad
\inferrule* [lab=\rel{T-Module}]
  {\forall f . \Delta(f) = \funty{\seq{\sigma}}{\tau} \land
   \tau <: \extern}
  {\expjudge{\Delta}{\return{\mathjs{\char123{} } \seq{x \mathjs{:} f} \mathjs{ \char125{}}}}}
\end{array}
}
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Statement list checking} & \hfil \fbox{$\stmtjudge{\Delta}{\Gamma}{\mathit{ss}}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-NoStatements}]
  { }
  {\stmtjudge{\Delta}{\Gamma}{\epsilon}{\tau}{\emptyset}}
\qquad
\inferrule* [lab=\rel{T-Statements}]
  {\forall i . \stmtjudge{\Delta}{\Gamma}{s_i}{\tau}{\varepsilon_i} \\\\
   n > 0 \\
   \varepsilon = \varepsilon_1 \seqcomp \ldots \seqcomp \varepsilon_n}
  {\stmtjudge{\Delta}{\Gamma}{\seq{s}}{\tau}{\varepsilon}}
\end{array}
}
\\ \\
\mbox{Statement checking} & \hfil \fbox{$\stmtjudge{\Delta}{\Gamma}{s}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Block}]
  {\stmtjudge{\Delta}{\Gamma}{\mathit{ss}}{\tau}{\varepsilon}}
  {\stmtjudge{\Delta}{\Gamma}{\block{\mathit{ss}}}{\tau}{\varepsilon}}
\qquad
\inferrule* [lab=\rel{T-ExprStmt}]
  {\exprjudge{\Delta}{\Gamma}{e}{\sigma}}
  {\stmtjudge{\Delta}{\Gamma}{e\mathjs{;}}{\tau}{\emptyset}}
\\ \\
\inferrule* [lab=\rel{T-If}]
  {\exprjudge{\Delta}{\Gamma}{e}{\boolish} \\\\
   \stmtjudge{\Delta}{\Gamma}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \varepsilon \cup \emptyset}
  {\stmtjudge{\Delta}{\Gamma}{\ifthen{e}{s}}{\tau}{\varepsilon'}}
\qquad
\inferrule* [lab=\rel{T-IfElse}]
  {\exprjudge{\Delta}{\Gamma}{e}{\boolish} \\\\
   \stmtjudge{\Delta}{\Gamma}{s_1}{\tau}{\varepsilon_1} \\
   \stmtjudge{\Delta}{\Gamma}{s_2}{\tau}{\varepsilon_2} \\\\
   \varepsilon = \varepsilon_1 \cup \varepsilon_2}
  {\stmtjudge{\Delta}{\Gamma}{\ifthenelse{e}{s_1}{s_2}}{\tau}{\varepsilon}}
\\ \\
\inferrule* [lab=\rel{T-ReturnExpr}]
  {\type(e) <: \tau \\
   \exprjudge{\Delta}{\Gamma}{e}{\tau}}
  {\stmtjudge{\Delta}{\Gamma}{\return{e}}{\tau}{\mustret}}
\qquad
\inferrule* [lab=\rel{T-ReturnVoid}]
  { }
  {\stmtjudge{\Delta}{\Gamma}{\mathtt{return;}}{\void}{\mustret}}
\\ \\
\inferrule* [lab=\rel{T-While}]
  {\exprjudge{\Delta}{\Gamma}{e}{\boolish} \\\\
   \stmtjudge{\Delta}{\Gamma}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \emptyset \cup \varepsilon - \{ \epsilon \}}
  {\stmtjudge{\Delta}{\Gamma}{\while{e}{s}}{\tau}{\varepsilon'}}
\qquad
\inferrule* [lab=\rel{T-DoWhile}]
  {\stmtjudge{\Delta}{\Gamma}{s}{\tau}{\varepsilon} \\\\
   \exprjudge{\Delta}{\Gamma}{e}{\boolish} \\\\
   \varepsilon' = \varepsilon - \{ \epsilon \}}
  {\stmtjudge{\Delta}{\Gamma}{\dowhile{s}{e}}{\tau}{\varepsilon'}}
\\ \\
\inferrule* [lab=\rel{T-For}]
  {[\exprjudge{\Delta}{\Gamma}{e_1}{\sigma_1}] \\
   [\exprjudge{\Delta}{\Gamma}{e_2}{\boolish}] \\
   [\exprjudge{\Delta}{\Gamma}{e_3}{\sigma_3}] \\\\
   \stmtjudge{\Delta}{\Gamma}{s}{\tau}{\varepsilon} \\
   \varepsilon' = \emptyset \cup \varepsilon - \{ \epsilon \}}
  {\stmtjudge{\Delta}{\Gamma}{\for{[e_1]}{[e_2]}{[e_3]}{s}}{\tau}{\varepsilon'}}
\end{array}
}
\end{array}
\]

\newsavebox{\switchcontrol}
\begin{lrbox}{\switchcontrol}
\begin{minipage}[t]{2.87in}
\vspace{-.25in}
\[
\varepsilon = \left\{ \begin{array}{ll}
                      \mustret & \mbox{if}\ \varepsilon_n = \mustret \land \forall i . \varepsilon_i \cup \emptyset = \emptyset \\
                      \bigcup \varepsilon_i - \{ \epsilon \} & \mbox{otherwise}
                      \end{array} \right.
\]
\end{minipage}
\end{lrbox}

\[
\begin{array}{lr}
\mbox{Statement checking (cont'd)} & \hfil \fbox{$\stmtjudge{\Delta}{\Gamma}{s}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Break}]
  { }
  {\stmtjudge{\Delta}{\Gamma}{\brk}{\tau}{\{ \epsilon \}}}
\qquad
\inferrule* [lab=\rel{T-BreakLabel}]
  { }
  {\stmtjudge{\Delta}{\Gamma}{\brkl{\mathit{lab}}}{\tau}{\{ \mathit{lab} \}}}
\\ \\
\inferrule* [lab=\rel{T-Continue}]
  { }
  {\stmtjudge{\Delta}{\Gamma}{\contl{[\mathit{lab}]}}{\tau}{\emptyset}}
\qquad
\inferrule* [lab=\rel{T-Label}]
  {\stmtjudge{\Delta}{\Gamma}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \varepsilon - \{ \mathit{lab} \}}
  {\stmtjudge{\Delta}{\Gamma}{\lab{\mathit{lab}}{s}}{\tau}{\varepsilon'}}
\\ \\
\inferrule* [lab=\rel{T-Switch}]
  {\exprjudge{\Delta}{\Gamma}{e}{\sigma} \\
   \sigma <: \extern \\\\
   \forall i . \mathit{cd}_i = \mathjs{case } v_i\mathjs{:}\,\mathit{ss}_i \Rightarrow \type(v_i) <: \sigma \\\\
   \forall i . \stmtjudge{\Delta}{\Gamma}{\mathit{cd}_i}{\tau}{\varepsilon_i} \\\\
   \usebox{\switchcontrol}}
                 %% \left\{\begin{array}{ll}
                 %%        \mustret & \mbox{if}\ \varepsilon_n = \mustret \land \forall i . \varepsilon_i \cup \emptyset = \emptyset \\
                 %%        (\varepsilon_n \cup \bigcup_{i<n} \varepsilon_i) - (L \cup \{ \epsilon \}) & \mbox{otherwise}
                 %%        \end{array}\right. }
  {\stmtjudge{\Delta}{\Gamma}{\switch{e}{\seq{\mathit{cd}}}}{\tau}{\varepsilon}}
\\ \\
\inferrule* [lab=\rel{T-EmptySwitch}]
  {\exprjudge{\Delta}{\Gamma}{e}{\sigma}}
  {\stmtjudge{\Delta}{\Gamma}{\switch{e}{}}{\tau}{\emptyset}}
\qquad
\inferrule* [lab=\rel{T-EmptyStatement}]
  { }
  {\stmtjudge{\Delta}{\Gamma}{\mathjs{;}}{\tau}{\emptyset}}
\end{array}
}
\\ \\
\mbox{Case checking} & \hfil \fbox{$\stmtjudge{\Delta}{\Gamma}{\mathit{cd}}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Case}]
  {\stmtjudge{\Delta}{\Gamma}{\mathit{ss}}{\tau}{\varepsilon}}
  {\stmtjudge{\Delta}{\Gamma}{\mathjs{case }v\mathjs{:}\,\mathit{ss}}{\tau}{\varepsilon}}
\qquad
\inferrule* [lab=\rel{T-Default}]
  {\stmtjudge{\Delta}{\Gamma}{\mathit{ss}}{\tau}{\varepsilon}}
  {\stmtjudge{\Delta}{\Gamma}{\mathjs{default:}\,\mathit{ss}}{\tau}{\varepsilon}}
\end{array}
}
\end{array}
\]

\clearpage

\[
(\Delta\cdot\Gamma)(x) = \left\{\begin{array}{ll}
                                \Gamma(x) & \mbox{if}\ x \in\dom(\Gamma) \\
                                \Delta(x) & \mbox{otherwise}
                                \end{array} \right.
\]

\[
\begin{array}{lr}
\mbox{Expression checking} & \hfil \fbox{$\exprjudge{\Delta}{\Gamma}{e}{\tau}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Constant}]
  {-2^{31} \leq n < 2^{32}}
  {\exprjudge{\Delta}{\Gamma}{n}{\constant}}
\qquad
\inferrule* [lab=\rel{T-Double}]
  { }
  {\exprjudge{\Delta}{\Gamma}{r}{\double}}
\\ \\
\inferrule* [lab=\rel{T-VarRef}]
  {(\Delta\cdot\Gamma)(x) = \tau}
  {\exprjudge{\Delta}{\Gamma}{x}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Assign}]
  {\exprjudge{\Delta}{\Gamma}{e}{\tau} \\
   \tau <: (\Delta\cdot\Gamma)(x)}
  {\exprjudge{\Delta}{\Gamma}{x\mathjs{ = }e}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-Load}]
  {m = 2^k - 1 \\
   (\Delta\cdot\Gamma)(x) = \arr{n}{\tau} \\\\
   \exprjudge{\Delta}{\Gamma}{e}{\intish}}
  {\exprjudge{\Delta}{\Gamma}{\getprop{x}{\paren{e\mathjs{ \& } m}\mathjs{ >> }n/8}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Store}]
  {m = 2^k - 1 \\
   (\Delta\cdot\Gamma)(x) = \arr{n}{\tau} \\\\
   \exprjudge{\Delta}{\Gamma}{e_1}{\intish} \\
   \exprjudge{\Delta}{\Gamma}{e_2}{\tau}}
  {\exprjudge{\Delta}{\Gamma}{\getprop{x}{\paren{e_1\mathjs{ \& } m}\mathjs{ >> }n/8}\mathjs{ = }e_2}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-IMul}]
  {(\Delta\cdot\Gamma)(f) = \imul \\\\
   \forall i . \exprjudge{\Delta}{\Gamma}{e_i}{\intish}}
  {\exprjudge{\Delta}{\Gamma}{\funcall{f}{e_1, e_2}}{\signed}}
\qquad
\inferrule* [lab=\rel{T-FunCall}]
  {(\Delta\cdot\Gamma)(f) = \funty{\seq{\sigma}}{\tau} \\\\
   \forall i . \exprjudge{\Delta}{\Gamma}{e_i}{\sigma_i}}
  {\exprjudge{\Delta}{\Gamma}{\funcall{f}{\seq{e}}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-FFI}]
  {(\Delta\cdot\Gamma)(f) = \function \\\\
   \forall i . \exprjudge{\Delta}{\Gamma}{e_i}{\extern}}
  {\exprjudge{\Delta}{\Gamma}{\funcall{f}{\seq{e}}}{\unk}}
\\ \\
\inferrule* [lab=\rel{T-Conditional}]
  {\exprjudge{\Delta}{\Gamma}{e_1}{\boolish} \\\\
   \exprjudge{\Delta}{\Gamma}{e_2}{\tau} \\
   \exprjudge{\Delta}{\Gamma}{e_3}{\tau}}
  {\exprjudge{\Delta}{\Gamma}{\ternary{e_1}{e_2}{e_3}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Paren}]
  {\forall i \leq n . \exprjudge{\Delta}{\Gamma}{e_i}{\tau_i}}
  {\exprjudge{\Delta}{\Gamma}{\paren{\seq{e}}}{\tau_n}}
\\ \\
\inferrule* [lab=\rel{T-Unop}]
  {\mathit{unop} : \_ \land \funty{\sigma}{\tau} \land \_ \\
   \exprjudge{\Delta}{\Gamma}{e}{\sigma}}
  {\exprjudge{\Delta}{\Gamma}{\mathit{unop}\ e}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Binop}]
  {\mathit{binop} : \_ \land \funty{\sigma_1, \sigma_2}{\tau} \land \_ \\\\
   \exprjudge{\Delta}{\Gamma}{e_1}{\sigma_1} \\
   \exprjudge{\Delta}{\Gamma}{e_2}{\sigma_2}}
  {\exprjudge{\Delta}{\Gamma}{e_1\ \mathit{binop}\ e_2}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-Sub}]
  {\exprjudge{\Delta}{\Gamma}{e}{\sigma} \\
   \sigma <: \tau}
  {\exprjudge{\Delta}{\Gamma}{e}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Cast}]
  {\exprjudge{\Delta}{\Gamma}{e}{\double}}
  {\exprjudge{\Delta}{\Gamma}{\mathjs{\~{}\~{}}e}{\signed}}
\end{array}
}
\end{array}
\]

\end{document}
