\documentclass{article}

\usepackage{mathpartir}
\usepackage{amssymb}

\newcommand{\ternary}[3]{{#1}\ \mathjs{?}\ {#2}\ \mathjs{:}\ {#3}}
\newcommand{\funcall}[2]{{#1}\mathjs{(}{#2}\mathjs{)}}
\newcommand{\paren}[1]{\mathjs{(}{#1}\mathjs{)}}
\newcommand{\dom}{\mathit{dom}}
\newcommand{\type}{\mathit{type}}
\newcommand{\funty}[2]{({#1}) \rightarrow {#2}}
\newcommand{\seq}[1]{\overline{{#1}}}
\newcommand{\mathjs}[1]{\mbox{\texttt{{#1}}}}
\newcommand{\mathjssm}[1]{\mbox{\texttt{\scriptsize {#1}}}}
\newcommand{\return}[1]{\mathjs{return }{#1}\mathjs{;}}
\newcommand{\fun}[3]{\mathjs{function }{#1}\mathjs{(}{#2}\mathjs{) \{ }{#3}\mathjs{ \}}}
\newcommand{\afun}[2]{\mathjs{function}\mathjs{(}{#1}\mathjs{) \{ }{#2}\mathjs{ \}}}
\newcommand{\var}[1]{\mathjs{var }{#1}\mathjs{;}}
\newcommand{\rel}[1]{\scriptsize [\textsc{#1}]}
\newcommand\defeq{\stackrel{\mbox{\tiny def}}{=}}
\newcommand{\while}[2]{\mathjs{while (}{#1}\mathjs{) }{#2}}
\newcommand{\dowhile}[2]{\mathjs{do }{#1}\mathjs{ while (}{#2}\mathjs{);}}
\newcommand{\for}[4]{\mathjs{for (}{#1}\mathjs{; }{#2}\mathjs{; }{#3}\mathjs{) }{#4}}
\newcommand{\switch}[2]{\mathjs{switch (}{#1}\mathjs{) \{ }{#2}\mathjs{ \}}}
\newcommand{\switchdef}[3]{\mathjs{switch (}{#1}\mathjs{) \{ }{#2}\mathjs{ default:}\,{#3}\mathjs{ \}}}
\newcommand{\brk}{\mathjs{break;}}
\newcommand{\brkl}[1]{\mathjs{break }{#1}\mathjs{;}}
\newcommand{\cont}{\mathjs{continue;}}
\newcommand{\contl}[1]{\mathjs{continue }{#1}\mathjs{;}}
\newcommand{\lab}[2]{{#1}\mathjs{:}\,{#2}}
\newcommand{\ifthen}[2]{\mathjs{if (}{#1}\mathjs{) }{#2}}
\newcommand{\ifthenelse}[3]{\mathjs{if (}{#1}\mathjs{) }{#2}\mathjs{ else }{#3}}
\newcommand{\block}[1]{\mathjs{\{ }{#1}\mathjs{ \}}}
\newcommand{\ok}{\mathrm{\mathbf{ok}}}
\newcommand{\rulebreak}{\vspace{.1in}\\}
\newcommand{\pjudge}[2]{{#1} \vdash {#2}\ \ok}
\newcommand{\fjudge}[3]{{#1};{#2} \vdash {#3}\ \ok}
\newcommand{\ejudge}[5]{{#1};{#2};{#3} \vdash {#4} : {#5}}
\newcommand{\sjudge}[7]{{#1};{#2};{#3};{#4} \vdash {#5} : {#6} / {#7}}
\newcommand{\cjudge}[8]{{#1};{#2};{#3};{#4} \vdash {#5} : {#6}, {#7} / {#8}}
\newcommand{\boolean}{\mathtt{bits1}}
\newcommand{\uintone}{\mathtt{uint8}}
\newcommand{\uinttwo}{\mathtt{uint16}}
\newcommand{\uintfour}{\mathtt{uint32}}
\newcommand{\uinteight}{\mathtt{uint64}}
\newcommand{\intone}{\mathtt{int8}}
\newcommand{\inttwo}{\mathtt{int16}}
\newcommand{\intfour}{\mathtt{int32}}
\newcommand{\inteight}{\mathtt{int64}}
\newcommand{\float}{\mathtt{float32}}
\newcommand{\double}{\mathtt{float64}}
\newcommand{\arr}[1]{\mathtt{array}_{#1}}
\newcommand{\Fun}{\mathtt{Function}}
\newcommand{\any}{\mathtt{jsval}}
\newcommand{\str}{\mathtt{string}}
\newcommand{\undef}{\mathtt{undefined}}
\newcommand{\void}{\mathtt{void}}
\newcommand{\nul}{\mathtt{null}}
\newcommand{\num}{\mathtt{number}}
\newcommand{\obj}{\mathtt{object}}
\newcommand{\mustret}{\mathsf{return}}
\newcommand{\seqcomp}{\mathrel{;}}
\newcommand{\getprop}[2]{{#1}\mathjs{[}{#2}\mathjs{]}}
\newcommand{\getpropsm}[2]{{#1}\mathjssm{[}{#2}\mathjssm{]}}
\newcommand{\longlong}[2]{\mathjs{[}{#1},{#2}\mathjs{]}}
\newcommand{\toint}[1]{{#1}\mathjs{ | 0}}
\newcommand{\touint}[1]{{#1}\mathjs{ >>> 0}}
\newcommand{\word}{\mathtt{bits32}}
\newcommand{\dword}{\mathtt{bits64}}
\newcommand{\function}{\mathtt{function}}
\newcommand{\union}[2]{{#1}\mathrel{|}{#2}}
\newcommand{\boolish}{\mathtt{boolish}}
\newcommand{\floor}{\mathtt{floor}}

\begin{document}

\title{\texttt{asm.js}}
\author{Dave Herman, Luke Wagner, and Alon Zakai}
\maketitle

\section{Abstract syntax}

\[
\begin{array}{rcl}
b, e, f, g, x, y, z & \in & \mathit{Identifier} \\
\mathtt{arguments} & \not\in & \mathit{Identifier} \\
\mathtt{eval} & \not\in & \mathit{Identifier} \\
\end{array}
\]

\[
\begin{array}{rcl}
P               & ::= & \function(b, e)\mathjs{ \{ } \seq{\mathit{imp}_x}\ \seq{\mathit{fn}_f}\ \mathit{exp}\mathjs{ \}} \\
\mathit{imp}_x  & ::= & \var{x \mathjs{ = } e\mathjs{.}y} \\
                &  |  & \var{x \mathjs{ = } e\mathjs{.}y(b)} \\
                &  |  & \var{x \mathjs{ = } \mathjs{new }e\mathjs{.}y(b)} \\
\mathit{exp}    & ::= & \return{f} \\
                &  |  & \return{\mathjs{\{ } \seq{x \mathjs{:} f} \mathjs{ \}}} \\
\mathit{fn}_f   & ::= & \fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \var{\seq{y\mathjs{ = }v}}\ \mathit{ss}} \\
\end{array}
\]

\[
\begin{array}{rcl}
s & ::= & \block{\mathit{ss}} \\
  &  |  & e\mathjs{;} \\
  &  |  & \ifthen{e}{s} \\
  &  |  & \ifthenelse{e}{s}{s} \\
  &  |  & \return{v} \\
  &  |  & \while{e}{s} \\
  &  |  & \dowhile{s}{e} \\
  &  |  & \for{e}{e}{e}{s} \\
  &  |  & \switch{e}{\seq{c}} \\
  &  |  & \switch{e}{\seq{c}\ d} \\
  &  |  & \brk \\
  &  |  & \brkl{\mathit{lab}} \\
  &  |  & \cont \\
  &  |  & \contl{\mathit{lab}} \\
  &  |  & \lab{\mathit{lab}}{s} \\
\\
\mathit{ss} & ::= & \seq{s} \\
\\
c & ::= & \mathjs{case }e\mathjs{:}\,\mathit{ss} \\
d & ::= & \mathjs{default:}\,\mathit{ss} \\
\mathit{cd} & ::= & c ~|~ d \\
\end{array}
\]

\[
\begin{array}{rcl}
\kappa_X & ::= & \toint{X} \\
         %% &  |  & X \mathjs{ \& 0xff} \\
         %% &  |  & X \mathjs{ \& 0xffff} \\
         &  |  & \touint{X} \\
         &  |  & \mathjs{+}X \\
         &  |  & \longlong{\touint{\getprop{X}{\mathjs{0}}}}{\toint{\getprop{X}{\mathjs{1}}}} \\
         &  |  & \longlong{\touint{\getprop{X}{\mathjs{0}}}}{\touint{\getprop{X}{\mathjs{1}}}} \\
         %% &  |  & X \mathjs{ + ''} \\
         %% &  |  & X \mathjs{ + ""} \\
%         &  |  & \mathjs{!!}X \\
\end{array}
\]

\[
\begin{array}{rcl}
v & ::= & \kappa_{\mathit{num}} \\
  &  |  & \longlong{\kappa_{\mathit{num}}}{\kappa_{\mathit{num}}} \\
  %% &  |  & \mathit{bool} \\
  %% &  |  & \mathit{str} \\
  %% &  |  & \mathjs{null} \\
\\
e & ::= & \kappa_{\mathit{num}} \\
  &  |  & \kappa_e \\
  &  |  & \mathit{lval} \\
  &  |  & \mathit{lval}\mathjs{ = }e \\
  &  |  & \funcall{f}{\seq{e}} \\
  &  |  & \mathit{unop}\ e \\
  &  |  & e\ \mathit{aop}\ e \\
  &  |  & e\ \mathjs{/}\ e \\
  &  |  & e\ \mathjs{\%}\ e \\
  &  |  & e\ \mathit{bop}\ e \\
  &  |  & e\ \mathit{relop}\ e \\
  &  |  & \ternary{e}{e}{e} \\
  &  |  & \paren{\seq{e}} \\
  &  |  & \longlong{e}{e} \\
  &  |  & \getprop{e}{\mathjs{0}} \\
  &  |  & \getprop{e}{\mathjs{1}} \\
\\
\mathit{unop} & ::= & \mathjs{\~{}} ~|~ \mathjs{-} ~|~ \mathjs{!} \\
\\
\mathit{aop} & ::= & \mathjs{+} ~|~ \mathjs{-} ~|~ \mathjs{*} \\
\mathit{bop} & ::= & \mathjs{|} ~|~ \mathjs{\&} ~|~ \mathjs{\^{}} ~|~ \mathjs{<<} ~|~ \mathjs{>>} ~|~ \mathjs{>>>} \\
\\
\mathit{relop} & ::= & \mathjs{<} ~|~ \mathjs{<=} ~|~ \mathjs{>} ~|~ \mathjs{>=} ~|~ \mathjs{!=} ~|~ \mathjs{==} \\
%% \mathit{binop} & ::= & \mathjs{<} ~|~ \mathjs{<=} ~|~ \mathjs{>} ~|~ \mathjs{>=} ~|~ \mathjs{!=} ~|~ \mathjs{==} \\
%%                &  |  & \mathjs{+} ~|~ \mathjs{-} ~|~ \mathjs{*} ~|~ \mathjs{/} ~|~ \mathjs{\%} \\
%%                &  |  & \mathjs{|} ~|~ \mathjs{\&} ~|~ \mathjs{\^{}} \\
%%                &  |  & \mathjs{<<} ~|~ \mathjs{>>} ~|~ \mathjs{>>>} \\
\\
\mathit{lval} & ::= & x \\
              &  |  & \getprop{x}{e} \\
              &  |  & \getprop{x}{\mathjs{0}} \\
              &  |  & \getprop{x}{\mathjs{1}} \\
\end{array}
\]

\section{Type rules}

\[
\begin{array}{rcl}
\sigma, \tau & ::= & \boolean ~|~ \word ~|~ \dword ~|~ \boolish \\
             &  |  & \intfour ~|~ \uintfour \\
             &  |  & \inteight ~|~ \uinteight \\
             &  |  & \double \\
             &  |  & \arr{\tau} ~|~ \function ~|~ \any \\
             &  |  & \floor \\
             &  |  & \funty{\seq{\sigma}}{\tau} \\
             &  |  & \void \\
             %% &  |  & (\union{\sigma}{\tau}) \\
%% \sigma, \tau & ::= & \mathtt{int} \\
%%              &  |  & \uintone ~|~ \uinttwo ~|~ \uintfour \\
%%              &  |  & \intone ~|~ \inttwo ~|~ \intfour \\
%%              &  |  & \float ~|~ \double \\
%%              &  |  & \arr{\tau} \\
%%              &  |  & \any ~|~ \undef ~|~ \nul ~|~ \str ~|~ \boolean ~|~ \num ~|~ \obj ~|~ \mathtt{function} \\
\end{array}
\]

\[
\begin{array}{rcl}
\ell        & ::= & \mathit{lab} ~|~ \epsilon \\
L           & ::= & \{ \seq{\ell} \} \\
\varepsilon & ::= & L ~|~ \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
L                       \seqcomp L'       & = & L \cup L' \\
\emptyset               \seqcomp \mustret & = & \mustret \\
\{ \ell, \seq{\ell'} \} \seqcomp \mustret & = & \{ \ell, \seq{\ell'} \} \\
\mustret                \seqcomp L        & = & \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
L        \cup \mustret & = & L \\
\mustret \cup L        & = & L \\
\mustret \cup \mustret & = & \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
%\type(\mathit{bool}) & = & \boolean \\
%\type(\mathit{str}) & = & \str \\
%\type(\mathit{null}) & = & \nul \\
%\type(X \mathjs{ \& 0xff}) & = & \intone \\
%\type(X \mathjs{ \& 0xffff}) & = & \inttwo \\
\type(\toint{X}) & = & \intfour \\
\type(\touint{X}) & = & \uintfour \\
\type(\mathjs{+}X) & = & \double \\
\type(\longlong{\touint{\getprop{X}{\mathjs{0}}}}{\toint{\getprop{X}{\mathjs{1}}}}) & = & \inteight \\
\type(\longlong{\touint{\getprop{X}{\mathjs{0}}}}{\touint{\getprop{X}{\mathjs{1}}}}) & = & \uinteight \\
%\type(X \mathjs{ + ''}) & = & \str \\
%\type(X \mathjs{ + ""}) & = & \str \\
%\type(\mathjs{!!}X) & = & \boolean \\
\end{array}
\]

%% NOTE: pure pointers will not be any

\[
\begin{array}{rcl}
\intfour, \uintfour   & <: & \word \\
\inteight, \uinteight & <: & \dword \\
\boolean              & <: & \boolish \\
\word                 & <: & \boolish \\
\word                 & <: & \double \\
\double               & <: & \any \\
\function             & <: & \any \\
\arr{\tau}            & <: & \any \\
\void                 & <: & \any \\
\floor                & <: & \funty{\double}{\double} \\
\funty{\sigma}{\tau}  & <: & \function \\
%% \sigma              & <: & \union{\sigma}{\tau} \\
%% \tau                & <: & \union{\sigma}{\tau} \\
%% \uintone, \uinttwo, \uintfour & <: & \word \\
%% \intone, \inttwo, \intfour    & <: & \word \\
%% \word                         & <: & \num \\
%% \float                        & <: & \num \\
%% \double                       & <: & \num \\
%% \undef                        & <: & \any \\
%% \nul                          & <: & \any \\
%% \boolean                      & <: & \any \\
%% \num                          & <: & \any \\
%% \obj                          & <: & \any \\
%% \mathtt{function}             & <: & \any \\
\end{array}
\]

%% \[
%% \boolish \defeq \union{\boolean}{\word}
%% \]

%% \[
%% \begin{array}{rcl}
%% \rho   & ::= & \{ \seq{x : \tau} \} \\
%% \Delta & ::= & \{ \seq{f : \funty{\seq{\sigma}}{\tau} } \} \\
%% \Gamma & ::= & \{ \seq{x : \tau} \} \\
%% \end{array}
%% \]

\[
\Gamma ::= \{ \seq{x : \tau} \} ~|~ \Gamma, \{ \seq{x : \tau} \}
\]

\[
\begin{array}{rcl}
M(\floor) & = & \floor \\
M(\mathtt{ceil}) & = & \funty{\double}{\double} \\
M(\mathtt{sin}) & = & \funty{\double}{\double} \\
M(\mathtt{cos}) & = & \funty{\double}{\double} \\
& \ldots \\
\end{array}
\]

\[
\begin{array}{rcl}
A(\mathtt{Uint8Array}) & = & \uintfour \\
A(\mathtt{Uint16Array}) & = & \uintfour \\
A(\mathtt{Uint32Array}) & = & \uintfour \\
A(\mathtt{Int8Array}) & = & \intfour \\
A(\mathtt{Int16Array}) & = & \intfour \\
A(\mathtt{Int32Array}) & = & \intfour \\
A(\mathtt{Float32Array}) & = & \double \\
A(\mathtt{Float64Array}) & = & \double \\
\end{array}
\]

%% \newcommand{\fjudge}[3]{{#1};{#2} \vdash {#3}\ \ok}
\newcommand{\Pjudge}[1]{\vdash {#1}\ \ok}
\newcommand{\impjudge}[4]{{#1};{#2};{#3} \vdash {#4}\ \ok}
\newcommand{\fnjudge}[2]{{#1} \vdash {#2}\ \ok}
\newcommand{\expjudge}[2]{{#1} \vdash {#2}\ \ok}
\newcommand{\stmtjudge}[5]{{#1};{#2} \vdash {#3} : {#4} / {#5}}
\newcommand{\exprjudge}[3]{{#1} \vdash {#2} : {#3}}
\newcommand{\notexprjudge}[3]{{#1} \not\vdash {#2} : {#3}}
\newcommand{\casejudge}[6]{{#1};{#2} \vdash {#3} : {#4}, {#5} / {#6}}

\[
\begin{array}{lr}
\mbox{Program checking} & \hfil \fbox{$\Pjudge{P}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Program}]
  {\{ \seq{x} \} \cap \{ \seq{f} \} = \emptyset \\
   \{ \seq{x} \} \cap \{ b, e \} = \emptyset \\
   \{ \seq{f} \} \cap \{ b, e \} = \emptyset \\\\
   \forall i . \impjudge{b}{e}{\Gamma_0}{\mathit{imp}_x} \\
   \forall i . \fnjudge{\Gamma_0, \Gamma_1}{\mathit{fn}_f} \\
   \forall i . \expjudge{\Gamma_0, \Gamma_1}{\mathit{exp}}}
  {\Pjudge{\function(b,e)\mathjs{ \{ }\seq{\mathit{imp}_x}\ \seq{\mathit{fn}_f}\ \mathit{exp}\mathjs{ \}}}}
\end{array}
}
\\ \\
\mbox{Import checking} & \hfil \fbox{$\impjudge{b}{e}{\Gamma}{\mathit{imp}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-ImportStd}]
  {\Gamma(x) = M(y)}
  {\impjudge{b}{e}{\Gamma}{\var{x \mathjs{ = } e\mathjs{.}y}}}
\qquad
\inferrule* [lab=\rel{T-ImportFFI}]
  {y \not\in\dom(M)}
  {\impjudge{b}{e}{\Gamma}{\var{x \mathjs{ = } e\mathjs{.}y}}}
\\ \\
\inferrule* [lab=\rel{T-View}]
  {\Gamma(x) = \arr{A(y)}}
  {\impjudge{b}{e}{\Gamma}{\var{x \mathjs{ = } e\mathjs{.}y(b)}}}
\qquad
\inferrule* [lab=\rel{T-NewView}]
  {\Gamma(x) = \arr{A(y)}}
  {\impjudge{b}{e}{\Gamma}{\var{x \mathjs{ = new } e\mathjs{.}y(b)}}}
%% \\ \\
%% \inferrule* [lab=\rel{T-Singleton}]
%%   {\forall f . \fjudge{\rho}{\Delta}{\mathit{fn}_f} \\
%%    f \in \{\seq{f}\} \\\\
%%    \Delta(f) = \funty{\seq{\sigma}}{\tau} \land \tau <: \any}
%%   {\pjudge{\rho}{\seq{\mathit{fn}_f}\ \return{f}}}
%% \qquad
%% \inferrule* [lab=\rel{T-Module}]
%%   {\forall f . \fjudge{\rho}{\Delta}{\mathit{fn}_f} \\
%%    \{\seq{g}\} \subseteq \{\seq{f}\} \\\\
%%    \forall g . \Delta(g) = \funty{\seq{\sigma}}{\tau} \land \tau <: \any}
%%   {\pjudge{\rho}{\seq{\mathit{fn}_f}\ \return{\mathjs{\{ } \seq{x \mathjs{:} g} \mathjs{ \}}}}}
\end{array}
}
\\ \\
\mbox{Function checking} & \hfil \fbox{$\fnjudge{\Gamma}{\mathit{fn}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Function}]
  {\{ \seq{x} \} \cap \{ \seq{y} \} = \emptyset \\
   \Gamma(f) = \funty{\seq{\sigma}}{\tau} \\
   \seq{\sigma} = \seq{\type(\kappa_x)} \\
   \tau \not= \void \\\\
   \stmtjudge{\Gamma, \{ \seq{x : \sigma}, \seq{y : \type(v)} \}}{\emptyset}{\mathit{ss}}{\tau}{\mustret}}
  {\fnjudge{\Gamma}{\fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \var{\seq{y\mathjs{ = }v}}\ \mathit{ss}}}}
\\ \\
\inferrule* [lab=\rel{T-VoidFunction}]
  {\{ \seq{x} \} \cap \{ \seq{y} \} = \emptyset \\
   \Gamma(f) = \funty{\seq{\sigma}}{\void} \\
   \seq{\sigma} = \seq{\type(\kappa_x)} \\\\
   \stmtjudge{\Gamma, \{ \seq{x : \sigma}, \seq{y : \type(v)} \}}{\emptyset}{\mathit{ss}}{\void}{\varepsilon}}
  {\fnjudge{\Gamma}{\fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \var{\seq{y\mathjs{ = }v}}\ \mathit{ss}}}}
%% \\ \\
%% \inferrule* [lab=\rel{T-Function}]
%%   {\forall i . \type(\kappa_{x_i}) = \sigma_i \\\\
%%    \sjudge{\rho}{\Delta}{\{\seq{x:\sigma},\seq{y:\type(v)}\}}{\emptyset}{\mathit{ss}}{\Delta(f)}{\mustret}}
%%   {\fjudge{\rho}{\Delta}{\fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \var{\seq{y\mathjs{ = }v}}\ \mathit{ss}}}}
\end{array}
}
\\ \\
\mbox{Export checking} & \hfil \fbox{$\expjudge{\Gamma}{\mathit{exp}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
%% FIXME: args should be <: jsval as well
\inferrule* [lab=\rel{T-Singleton}]
  {\Gamma(f) = \funty{\seq{\sigma}}{\tau} \\
   \tau <: \any }
  {\expjudge{\Gamma}{\return{f}}}
\qquad
\inferrule* [lab=\rel{T-Module}]
  {\forall f . \Gamma(f) = \funty{\seq{\sigma}}{\tau} \land \tau <: \any}
  {\expjudge{\Gamma}{\return{\mathjs{\{ } \seq{x \mathjs{:} f} \mathjs{ \}}}}}
\end{array}
}
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Statement list checking} & \hfil \fbox{$\stmtjudge{\Gamma}{L}{\mathit{ss}}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-NoStatements}]
  { }
  {\stmtjudge{\Gamma}{L}{\epsilon}{\tau}{\emptyset}}
\qquad
\inferrule* [lab=\rel{T-Statements}]
  {\forall i . \stmtjudge{\Gamma}{L}{s_i}{\tau}{\varepsilon_i} \\\\
   n > 0 \\
   \varepsilon = \varepsilon_1 \seqcomp \ldots \seqcomp \varepsilon_n}
  {\stmtjudge{\Gamma}{L}{\seq{s}}{\tau}{\varepsilon}}
\end{array}
}
\\ \\
\mbox{Statement checking} & \hfil \fbox{$\stmtjudge{\Gamma}{L}{s}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Block}]
  {\stmtjudge{\Gamma}{\emptyset}{\mathit{ss}}{\tau}{\varepsilon}}
  {\stmtjudge{\Gamma}{L}{\block{\mathit{ss}}}{\tau}{\varepsilon}}
\qquad
\inferrule* [lab=\rel{T-ExprStmt}]
  {\exprjudge{\Gamma}{e}{\sigma}}
  {\stmtjudge{\Gamma}{L}{e\mathjs{;}}{\tau}{\emptyset}}
\\ \\
\inferrule* [lab=\rel{T-If}]
  {\exprjudge{\Gamma}{e}{\sigma <: \boolish} \\\\
   \stmtjudge{\Gamma}{\emptyset}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \varepsilon \cup \emptyset}
  {\stmtjudge{\Gamma}{L}{\ifthen{e}{s}}{\tau}{\varepsilon'}}
\qquad
\inferrule* [lab=\rel{T-IfElse}]
  {\exprjudge{\Gamma}{e}{\sigma <: \boolish} \\\\
   \stmtjudge{\Gamma}{\emptyset}{s_1}{\tau}{\varepsilon_1} \\
   \stmtjudge{\Gamma}{\emptyset}{s_2}{\tau}{\varepsilon_2} \\\\
   \varepsilon = \varepsilon_1 \cup \varepsilon_2}
  {\stmtjudge{\Gamma}{L}{\ifthenelse{e}{s_1}{s_2}}{\tau}{\varepsilon}}
\\ \\
\inferrule* [lab=\rel{T-ReturnExpr}]
  {\exprjudge{\Gamma}{e}{\tau}}
  {\stmtjudge{\Gamma}{L}{\return{e}}{\tau}{\mustret}}
\qquad
\inferrule* [lab=\rel{T-ReturnVoid}]
  { }
  {\stmtjudge{\Gamma}{L}{\mathtt{return;}}{\void}{\mustret}}
\\ \\
\inferrule* [lab=\rel{T-While}]
  {\exprjudge{\Gamma}{e}{\sigma <: \boolish} \\\\
   \stmtjudge{\Gamma}{L \cup \{ \epsilon \}}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \emptyset \cup \varepsilon - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\while{e}{s}}{\tau}{\varepsilon'}}
\qquad
\inferrule* [lab=\rel{T-DoWhile}]
  {\stmtjudge{\Gamma}{L \cup \{ \epsilon \}}{s}{\tau}{\varepsilon} \\\\
   \exprjudge{\Gamma}{e}{\sigma <: \boolish} \\\\
   \varepsilon' = \varepsilon - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\dowhile{s}{e}}{\tau}{\varepsilon'}}
\\ \\
%% FIXME: need to enforce boolish
%% FIXME: could allow empty clauses
\inferrule* [lab=\rel{T-For}]
  {\forall i . \exprjudge{\Gamma}{e_i}{\sigma_i} \\\\
   \stmtjudge{\Gamma}{L \cup \{ \epsilon \}}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \emptyset \cup \varepsilon - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\for{e_1}{e_2}{e_3}{s}}{\tau}{\varepsilon'}}
\end{array}
}
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Statement checking (cont'd)} & \hfil \fbox{$\stmtjudge{\Gamma}{L}{s}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Break}]
  { }
  {\stmtjudge{\Gamma}{L}{\brk}{\tau}{\{ \epsilon \}}}
\qquad
\inferrule* [lab=\rel{T-BreakLabel}]
  { }
  {\stmtjudge{\Gamma}{L}{\brkl{\mathit{lab}}}{\tau}{\{ \mathit{lab} \}}}
\\ \\
\inferrule* [lab=\rel{T-Continue}]
  { }
  {\stmtjudge{\Gamma}{L}{\cont}{\tau}{\emptyset}}
\qquad
\inferrule* [lab=\rel{T-ContinueLabel}]
  { }
  {\stmtjudge{\Gamma}{L}{\contl{\mathit{lab}}}{\tau}{\emptyset}}
\\ \\
\inferrule* [lab=\rel{T-Label}]
  {\stmtjudge{\Gamma}{L \cup \{ \mathit{lab} \}}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \varepsilon - (L \cup \{ \mathit{lab} \})}
  {\stmtjudge{\Gamma}{L}{\lab{\mathit{lab}}{s}}{\tau}{\varepsilon'}}
\\ \\
%% \inferrule* [lab=\rel{T-Switch}]
%%   {\ejudge{\rho}{\Delta}{\Gamma}{e}{\sigma} \\\\
%%    \forall i . \cjudge{\rho}{\Delta}{\Gamma}{L \cup \{ \epsilon \}}{c_i}{\sigma}{\tau}{\varepsilon_i} \\\\
%%    \varepsilon = (\bigcup_i \varepsilon_i) - (L \cup \{ \epsilon \})}
%%   {\sjudge{\rho}{\Delta}{\Gamma}{L}{\switch{e}{\seq{c}}}{\tau}{\varepsilon}}
%% \\ \\
%% FIXME: add rule to handle empty switch
\inferrule* [lab=\rel{T-Switch}]
  {\exprjudge{\Gamma}{e}{\sigma} \\\\
   \forall i . \casejudge{\Gamma}{L \cup \{ \epsilon \}}{c_i}{\sigma}{\tau}{\varepsilon_i} \\\\
   \casejudge{\Gamma}{L \cup \{ \epsilon \}}{\mathit{cd}}{\sigma}{\tau}{\varepsilon} \\\\
   \varepsilon \not= \mustret \lor \exists i . \varepsilon_i \cup \emptyset \not= \emptyset \\\\
   \varepsilon' = (\varepsilon \cup \bigcup_i \varepsilon_i) - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\switch{e}{\seq{c}\ \mathit{cd}}}{\tau}{\varepsilon'}}
\qquad
\inferrule* [lab=\rel{T-SwitchReturn}]
  {\exprjudge{\Gamma}{e}{\sigma} \\\\
   \forall i . \casejudge{\Gamma}{L \cup \{ \epsilon \}}{c_i}{\sigma}{\tau}{\varepsilon_i} \\\\
   \forall i . \varepsilon_i \cup \emptyset = \emptyset \\\\
   \casejudge{\Gamma}{L \cup \{ \epsilon \}}{\mathit{cd}}{\sigma}{\tau}{\mustret}}
  {\stmtjudge{\Gamma}{L}{\switch{e}{\seq{c}\ \mathit{cd}}}{\tau}{\mustret}}
\end{array}
}
\\ \\
\mbox{Case checking} & \hfil \fbox{$\casejudge{\Gamma}{L}{\mathit{cd}}{\sigma}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Case}]
  {\exprjudge{\Gamma}{e}{\sigma} \\\\
   \stmtjudge{\Gamma}{L}{\mathit{ss}}{\tau}{\varepsilon}}
  {\casejudge{\Gamma}{L}{\mathjs{case }e\mathjs{:}\,\mathit{ss}}{\sigma}{\tau}{\varepsilon}}
\qquad
\inferrule* [lab=\rel{T-Default}]
  {\stmtjudge{\Gamma}{L}{\mathit{ss}}{\tau}{\varepsilon}}
  {\casejudge{\Gamma}{L}{\mathjs{default:}\,\mathit{ss}}{\sigma}{\tau}{\varepsilon}}
\end{array}
}
\end{array}
\]

%% FIXME: add update operators (+=, ++, etc)

\[
\begin{array}{lr}
\mbox{Expression checking} & \hfil \fbox{$\exprjudge{\Gamma}{e}{\tau}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Number}]
  { }
  {\exprjudge{\Gamma}{\kappa_{\mathit{num}}}{\type(\kappa_{\mathit{num}})}}
\qquad
\inferrule* [lab=\rel{T-Cast}]
  {\kappa_e = \toint{(e_1\ \mathjs{/}\ e_2)} \Rightarrow \exists i . \notexprjudge{\Gamma}{e_i}{\intfour} \\\\
   e = e_1\ \mathit{aop}\ e_2 \Rightarrow \exists i . \notexprjudge{\Gamma}{e_i}{\tau <: \word} \\\\
   \exprjudge{\Gamma}{e}{\tau}}
  {\exprjudge{\Gamma}{\kappa_e}{\type(\kappa_e)}}
%% \inferrule* [lab=\rel{T-Cast}]
%%   {\exprjudge{\Gamma}{e}{\tau} \\\\
%%    e = \funcall{f}{\seq{e}} \Rightarrow f \in \dom(\Delta)}
%%   {\exprjudge{\Gamma}{\kappa_e}{\type(\kappa_e)}}
\\ \\
\inferrule* [lab=\rel{T-VarRef}]
  {\Gamma(x) = \tau}
  {\exprjudge{\Gamma}{x}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Assign}]
  {\Gamma(x) = \tau \\
   \exprjudge{\Gamma}{e}{\tau}}
  {\exprjudge{\Gamma}{x\mathjs{ = }e}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-Load}]
  {\Gamma(x) = \arr{\tau} \\
   \exprjudge{\Gamma}{e}{\uintfour}}
  {\exprjudge{\Gamma}{\getprop{x}{e}}{\tau}}
  %% {\type(\rho(x)) = \arr{\tau} \\\\
  %%  \exprjudge{\Gamma}{e}{\sigma} \\
  %%  \sigma <: \word \\\\
  %%  \type(\kappa_{\getpropsm{x}{e}}) = \tau}
  %% {\exprjudge{\Gamma}{\kappa_{\getpropsm{x}{e}}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Store}]
  {\exprjudge{\Gamma}{e_1}{\uintfour} \\
   \exprjudge{\Gamma}{e_2}{\Gamma(x)}}
  {\exprjudge{\Gamma}{\getprop{x}{e_1}\mathjs{ = }e_2}{\tau}}
  %% {\type(\rho(x)) = \arr{\tau} \\\\
  %%  \exprjudge{\Gamma}{e_1}{\sigma} \\
  %%  \sigma <: \word \\\\
  %%  \exprjudge{\Gamma}{e_2}{\tau}}
  %% {\exprjudge{\Gamma}{\getprop{x}{e_1}\mathjs{ = }e_2}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-LowUint}]
  {\exprjudge{\Gamma}{e}{\uinteight}}
  {\exprjudge{\Gamma}{\getprop{e}{\mathjs{0}}}{\uintfour}}
\qquad
\inferrule* [lab=\rel{T-LowInt}]
  {\exprjudge{\Gamma}{e}{\inteight}}
  {\exprjudge{\Gamma}{\getprop{e}{\mathjs{0}}}{\intfour}}
\qquad
\inferrule* [lab=\rel{T-HighUint}]
  {\exprjudge{\Gamma}{e}{\tau <: \dword}}
  {\exprjudge{\Gamma}{\getprop{e}{\mathjs{1}}}{\uintfour}}
\\ \\
\inferrule* [lab=\rel{T-FunCall}]
  {\Gamma(f) = \funty{\seq{\sigma}}{\tau} \\\\
   \forall i . \exprjudge{\Gamma}{e_i}{\sigma_i}}
  {\exprjudge{\Gamma}{\funcall{f}{\seq{e}}}{\tau}}
%% \\ \\
%% \inferrule* [lab=\rel{T-StdLib}]
%%   {e = {\funcall{f}{\seq{e}}} \\\\
%%    f \not\in\dom(\Delta) \\
%%    f \not\in\dom(\Gamma) \\\\
%%    \rho(f) = \funty{\seq{\sigma}}{\tau} \\\\
%%    \forall i . \exprjudge{\Gamma}{e_i}{\sigma_i} \\
%%    \type(\kappa_e) = \tau}
%%   {\exprjudge{\Gamma}{\kappa_e}{\tau}}
\qquad
\inferrule* [lab=\rel{T-FFI}]
  {\Gamma(f) = \function \\\\
   \forall i . \exprjudge{\Gamma}{e_i}{\sigma_i <: \any}}
  {\exprjudge{\Gamma}{\funcall{f}{\seq{e}}}{\any}}
%% \inferrule* [lab=\rel{T-FFI}]
%%   {f \not\in\dom(\Delta) \\
%%    f \not\in\dom(\Gamma) \\\\
%%    \rho(f) = \mathtt{function} \\\\
%%    \forall i . \exprjudge{\Gamma}{e_i}{\sigma_i}}
%%   {\exprjudge{\Gamma}{\funcall{f}{\seq{e}}}{\any}}
%% \\ \\
%% \inferrule* [lab=\rel{T-UnaryOp}]
%%   {\type(\mathit{unop}) = \sigma \rightarrow \tau \\
%%    \ejudge{\rho}{\Delta}{\Gamma}{e}{\sigma}}
%%   {\ejudge{\rho}{\Delta}{\Gamma}{\mathit{unop}\ e}{\tau}}
%% \\ \\
%% \inferrule* [lab=\rel{T-BinaryOp}]
%%   {\forall i \in \{1,2\} . \ejudge{\rho}{\Delta}{\Gamma}{e_i}{\sigma_i} \\
%%    \type(\mathit{binop}) = \sigma_1 \times \sigma_2 \rightarrow \tau}
%%   {\ejudge{\rho}{\Delta}{\Gamma}{e_1\ \mathit{binop}\ e_2}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-Conditional}]
  {\exprjudge{\Gamma}{e_1}{\sigma <: \boolish} \\
   \forall i . \exprjudge{\Gamma}{e_i}{\tau}}
  {\exprjudge{\Gamma}{\ternary{e_1}{e_2}{e_3}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Paren}]
  {\forall i \leq n . \exprjudge{\Gamma}{e_i}{\tau_i}}
  {\exprjudge{\Gamma}{\paren{\seq{e}}}{\tau_n}}
\\ \\
\inferrule* [lab=\rel{T-IArith}]
  {\forall i . \exprjudge{\Gamma}{e_i}{\tau <: \word}}
  {\exprjudge{\Gamma}{\toint{(e_1\ \mathit{aop}\ e_2)}}{\intfour}}
\qquad
\inferrule* [lab=\rel{T-UArith}]
  {\forall i . \exprjudge{\Gamma}{e_i}{\tau <: \word}}
  {\exprjudge{\Gamma}{\touint{(e_1\ \mathit{aop}\ e_2)}}{\uintfour}}
\\ \\
\inferrule* [lab=\rel{T-FArith}]
  {\forall i . \exprjudge{\Gamma}{e_i}{\tau_i <: \double}}
  {\exprjudge{\Gamma}{e_1\ \mathit{aop}\ e_2}{\double}}
\end{array}
}
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Expression checking (cont'd)} & \hfil \fbox{$\exprjudge{\Gamma}{e}{\tau}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-IDiv}]
  {\forall i . \exprjudge{\Gamma}{e_i}{\intfour}}
  {\exprjudge{\Gamma}{\toint{(e_1\ \mathjs{/}\ e_2)}}{\intfour}}
\qquad
\inferrule* [lab=\rel{T-UDiv}]
  {\Gamma(f) = \floor \\\\
   \forall i . \exprjudge{\Gamma}{e_i}{\uintfour}}
  {\exprjudge{\Gamma}{\funcall{f}{e_1\ \mathjs{/}\ e_2}}{\uintfour}}
%% \inferrule* [lab=\rel{T-UDiv}]
%%   {f \not\in \Gamma \\
%%    f \not\in \Delta \\
%%    \rho(f) = \floor \\\\
%%    \forall i \in \{1,2\} . \exprjudge{\Gamma}{e_i}{\uintfour}}
%%   {\exprjudge{\Gamma}{\funcall{f}{e_1\ \mathjs{/}\ e_2}}{\uintfour}}
\qquad
\inferrule* [lab=\rel{T-FDiv}]
  {\forall i . \exprjudge{\Gamma}{e_i}{\tau_i <: \double}}
  {\exprjudge{\Gamma}{e_1\ \mathjs{/}\ e_2}{\double}}
\\ \\
\inferrule* [lab=\rel{T-IMod}]
  {\forall i . \exprjudge{\Gamma}{e_i}{\intfour}}
  {\exprjudge{\Gamma}{e_1\ \mathjs{\%}\ e_2}{\intfour}}
\qquad
\inferrule* [lab=\rel{T-UMod}]
  {\forall i . \exprjudge{\Gamma}{e_i}{\uintfour}}
  {\exprjudge{\Gamma}{e_1\ \mathjs{\%}\ e_2}{\uintfour}}
\qquad
\inferrule* [lab=\rel{T-FMod}]
  {\forall i . \exprjudge{\Gamma}{e_i}{\tau_i <: \double}}
  {\exprjudge{\Gamma}{e_1\ \mathjs{\%}\ e_2}{\double}}
\\ \\
\inferrule* [lab=\rel{T-Rel}]
  {\forall i . \exprjudge{\Gamma}{e_i}{\tau <: \double}}
  {\exprjudge{\Gamma}{e_1\ \mathit{relop}\ e_2}{\boolean}}
\qquad
\inferrule* [lab=\rel{T-Bitwise}]
  {\forall i . \exprjudge{\Gamma}{e_i}{\tau_i <: \word}}
  {\exprjudge{\Gamma}{e_1\ \mathit{bop}\ e_2}{\intfour}}
\\ \\
\inferrule* [lab=\rel{T-BitwiseNot}]
  {\exprjudge{\Gamma}{e}{\tau <: \word}}
  {\exprjudge{\Gamma}{\mathjs{\~{}}e}{\intfour}}
\qquad
\inferrule* [lab=\rel{T-Not}]
  {\exprjudge{\Gamma}{e}{\tau <: \boolish}}
  {\exprjudge{\Gamma}{\mathjs{!}e}{\boolean}}
\qquad
\inferrule* [lab=\rel{T-Negate}]
  {\exprjudge{\Gamma}{e}{\tau <: \word}}
  {\exprjudge{\Gamma}{\mathjs{-}e}{\intfour}}
\end{array}
}
\end{array}
\]


\end{document}
