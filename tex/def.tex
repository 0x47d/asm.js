\documentclass{article}

\usepackage{mathpartir}
\usepackage{amssymb}

\newcommand{\ternary}[3]{{#1}\ \mathjs{?}\ {#2}\ \mathjs{:}\ {#3}}
\newcommand{\funcall}[2]{{#1}\mathjs{(}{#2}\mathjs{)}}
\newcommand{\paren}[1]{\mathjs{(}{#1}\mathjs{)}}
\newcommand{\dom}{\mathit{dom}}
\newcommand{\type}{\mathit{type}}
\newcommand{\funty}[2]{({#1}) \rightarrow {#2}}
\newcommand{\seq}[1]{\overline{{#1}}}
\newcommand{\mathjs}[1]{\mbox{\texttt{{#1}}}}
\newcommand{\mathjssm}[1]{\mbox{\texttt{\scriptsize {#1}}}}
\newcommand{\return}[1]{\mathjs{return }{#1}\mathjs{;}}
\newcommand{\fun}[3]{\mathjs{function }{#1}\mathjs{(}{#2}\mathjs{) \char123{} }{#3}\mathjs{ \char125{}}}
\newcommand{\afun}[2]{\mathjs{function}\mathjs{(}{#1}\mathjs{) \char123{} }{#2}\mathjs{ \char125{}}}
\newcommand{\var}[1]{\mathjs{var }{#1}\mathjs{;}}
\newcommand{\rel}[1]{\scriptsize [\textsc{#1}]}
\newcommand\defeq{\stackrel{\mbox{\tiny def}}{=}}
\newcommand{\while}[2]{\mathjs{while (}{#1}\mathjs{) }{#2}}
\newcommand{\dowhile}[2]{\mathjs{do }{#1}\mathjs{ while (}{#2}\mathjs{);}}
\newcommand{\for}[4]{\mathjs{for (}{#1}\mathjs{; }{#2}\mathjs{; }{#3}\mathjs{) }{#4}}
\newcommand{\switch}[2]{\mathjs{switch (}{#1}\mathjs{) \char123{} }{#2}\mathjs{ \char125{}}}
\newcommand{\switchdef}[3]{\mathjs{switch (}{#1}\mathjs{) \char123{} }{#2}\mathjs{ default:}\,{#3}\mathjs{ \char125{}}}
\newcommand{\brk}{\mathjs{break;}}
\newcommand{\brkl}[1]{\mathjs{break }{#1}\mathjs{;}}
\newcommand{\cont}{\mathjs{continue;}}
\newcommand{\contl}[1]{\mathjs{continue }{#1}\mathjs{;}}
\newcommand{\lab}[2]{{#1}\mathjs{:}\,{#2}}
\newcommand{\ifthen}[2]{\mathjs{if (}{#1}\mathjs{) }{#2}}
\newcommand{\ifthenelse}[3]{\mathjs{if (}{#1}\mathjs{) }{#2}\mathjs{ else }{#3}}
\newcommand{\block}[1]{\mathjs{\char123{} }{#1}\mathjs{ \char125{}}}
\newcommand{\ok}{\mathrm{\mathbf{ok}}}
\newcommand{\rulebreak}{\vspace{.1in}\\}
\newcommand{\bit}{\mathtt{bit}}
\newcommand{\unsigned}{\mathtt{unsigned}}
\newcommand{\intsm}{\mathjssm{int}}
\newcommand{\doublesm}{\mathjssm{double}}
\newcommand{\signed}{\mathtt{signed}}
\newcommand{\constant}{\mathtt{constant}}
\newcommand{\double}{\mathtt{double}}
\newcommand{\arr}[2]{\mathtt{array}^{#1}_{#2}}
\newcommand{\extern}{\mathtt{extern}}
\newcommand{\unk}{\mathtt{unknown}}
\newcommand{\str}{\mathtt{string}}
\newcommand{\undef}{\mathtt{undefined}}
\newcommand{\void}{\mathtt{void}}
\newcommand{\nul}{\mathtt{null}}
\newcommand{\num}{\mathtt{number}}
\newcommand{\obj}{\mathtt{object}}
\newcommand{\mustret}{\mathsf{return}}
\newcommand{\seqcomp}{\mathrel{;}}
\newcommand{\getprop}[2]{{#1}\mathjs{[}{#2}\mathjs{]}}
\newcommand{\getpropsm}[2]{{#1}\mathjssm{[}{#2}\mathjssm{]}}
\newcommand{\longlong}[2]{\mathjs{[}{#1},{#2}\mathjs{]}}
\newcommand{\toint}[1]{\mathjs{\~{}\~{}}{#1}}
\newcommand{\todouble}[1]{\mathjs{+}{#1}}
\renewcommand{\int}{\mathtt{int}}
\newcommand{\dword}{\mathtt{bits64}}
\newcommand{\function}{\mathtt{function}}
\newcommand{\union}[2]{{#1}\mathrel{|}{#2}}
\newcommand{\boolish}{\mathtt{boolish}}
\newcommand{\floor}{\mathtt{floor}}
\newcommand{\imul}{\mathtt{imul}}
\newcommand{\intish}{\mathtt{intish}}

\newcommand{\progjudge}[1]{\vdash {#1}\ \ok}
\newcommand{\impjudge}[4]{{#1};{#2};{#3} \vdash {#4}\ \ok}
\newcommand{\fnjudge}[2]{{#1} \vdash {#2}\ \ok}
\newcommand{\expjudge}[2]{{#1} \vdash {#2}\ \ok}
\newcommand{\stmtjudge}[5]{{#1};{#2} \vdash {#3} : {#4} / {#5}}
\newcommand{\exprjudge}[3]{{#1} \vdash {#2} : {#3}}
%% \newcommand{\notexprjudge}[3]{{#1} \not\vdash {#2} : {#3}}
\newcommand{\casejudge}[6]{{#1};{#2} \vdash {#3} : {#4}, {#5} / {#6}}

\begin{document}

\title{\texttt{asm.js}}
\author{Dave Herman, Luke Wagner, and Alon Zakai}
\maketitle

\section{Abstract syntax}

\[
\begin{array}{rcl}
b, e, f, g, x, y, z               & \in & \mathit{Identifier} \\
\mathtt{arguments}, \mathtt{eval} & \not\in & \mathit{Identifier} \\
\end{array}
\]

\[
\begin{array}{rcl}
P               & ::= & \fun{[g]}{[e[, b]]}{\mathjs{"use asm"; } \seq{\mathit{imp}_x}\ \seq{\mathit{fn}_f}\ \mathit{exp}} \\
\mathit{imp}_x  & ::= & \var{x \mathjs{ = } e\mathjs{.}y} \\
                &  |  & \var{x \mathjs{ = } \mathjs{new }\funcall{e\mathjs{.}y}{b}} \\
\mathit{exp}    & ::= & \return{f} \\
                &  |  & \return{\mathjs{\char123{} } \seq{x \mathjs{:} f} \mathjs{ \char125{}}} \\
\mathit{fn}_f   & ::= & \fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \var{\seq{y\mathjs{ = }v}}\ \mathit{ss}} \\
\end{array}
\]

\[
\begin{array}{rcl}
s & ::= & \block{\mathit{ss}} \\
  &  |  & e\mathjs{;} \\
  &  |  & \mathjs{;} \\
  &  |  & \ifthen{e}{s} \\
  &  |  & \ifthenelse{e}{s}{s} \\
  &  |  & \return{e} \\
  &  |  & \while{e}{s} \\
  &  |  & \dowhile{s}{e} \\
  &  |  & \for{[e]}{[e]}{[e]}{s} \\
  &  |  & \switch{e}{\seq{c}} \\
  &  |  & \switch{e}{\seq{c}\ d} \\
  &  |  & \brk \\
  &  |  & \brkl{\mathit{lab}} \\
  &  |  & \cont \\
  &  |  & \contl{\mathit{lab}} \\
  &  |  & \lab{\mathit{lab}}{s} \\
\\
\mathit{ss} & ::= & \seq{s} \\
\\
c & ::= & \mathjs{case }e\mathjs{:}\,\mathit{ss} \\
d & ::= & \mathjs{default:}\,\mathit{ss} \\
\mathit{cd} & ::= & c ~|~ d \\
\end{array}
\]

\[
\kappa_x ::= \toint{x} ~|~ \todouble{x} ~|~ x\mathjs{|0} ~|~ x\mathjs{>>>0} \\
\]

\[
\begin{array}{rcl}
v & ::= & r ~|~ n \\
\\
e & ::= & v \\
  &  |  & \mathit{lval} \\
  &  |  & \mathit{lval}\mathjs{ = }e \\
  &  |  & \funcall{f}{\seq{e}} \\
  &  |  & \mathit{unop}\ e \\
  &  |  & e\ \mathit{binop}\ e \\
  &  |  & \ternary{e}{e}{e} \\
  &  |  & \paren{\seq{e}} \\
\\
\mathit{unop} & ::= & \mathjs{+} ~|~ \mathjs{\~{}} ~|~ \mathjs{!} \\
\\
\mathit{binop} & ::= & \mathjs{+} ~|~ \mathjs{-} ~|~ \mathjs{*} ~|~ \mathjs{/} ~|~ \mathjs{\%} \\
               &  |  & \mathjs{|} ~|~ \mathjs{\&} ~|~ \mathjs{\^{}} ~|~ \mathjs{<<} ~|~ \mathjs{>>} ~|~ \mathjs{>>>} \\
               &  |  & \mathjs{<} ~|~ \mathjs{<=} ~|~ \mathjs{>} ~|~ \mathjs{>=} ~|~ \mathjs{!=} ~|~ \mathjs{==} \\
\mathit{lval} & ::= & x ~|~ \getprop{x}{\paren{e\mathjs{ \& }m}\mathjs{ >> }n} \\
\end{array}
\]

\section{Type rules}

\[
\sigma, \tau ::= \bit ~|~ \double ~|~ \int ~|~ \signed ~|~ \unsigned ~|~ \boolish ~|~ \intish ~|~ \void ~|~ \unk
\]

\[
\rho ::= \tau ~|~ \arr{n}{\tau} ~|~ \imul ~|~ (\funty{\seq{\sigma}}{\tau}) \land \ldots \land (\funty{\seq{\sigma'}}{\tau'}) ~|~ \function
\]

\[
\begin{array}{rcl}
\ell        & ::= & \mathit{lab} ~|~ \epsilon \\
L           & ::= & \{ \seq{\ell} \} \\
\varepsilon & ::= & L ~|~ \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
L                       \seqcomp L'       & = & L \cup L' \\
\emptyset               \seqcomp \mustret & = & \mustret \\
\{ \ell, \seq{\ell'} \} \seqcomp \mustret & = & \{ \ell, \seq{\ell'} \} \\
\mustret                \seqcomp L        & = & \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
L        \cup \mustret & = & L \\
\mustret \cup L        & = & L \\
\mustret \cup \mustret & = & \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
\type(\toint{X})      & = & \int \\
\type(\todouble{X})   & = & \double \\
\type(n)              & = & \int \\
\type(r)              & = & \double \\
\type(X\mathjs{|0})   & = & \signed \\
\type(X\mathjs{>>>0}) & = & \unsigned \\
\end{array}
\]

%% NOTE: pure pointers will not be jsval

\[
\begin{array}{rcl}
\constant                                                                           & <: & \signed, \unsigned \\
\signed, \unsigned                                                                  & <: & \int, \extern \\
\bit, \int                                                                          & <: & \boolish \\
\double                                                                             & <: & \extern \\
\unk, \int                                                                          & <: & \intish \\
\end{array}
\]

\[
\begin{array}{rcl}
M(\imul) & : & \imul \\
M(\mathtt{ceil}), M(\mathtt{sin}), M(\mathtt{cos}) & : & \funty{\double}{\double} \\
\end{array}
\]

\[
\begin{array}{rcl}
A(\mathtt{Uint8Array}), A(\mathtt{Int8Array})   & = & \arr{8}{\intsm} \\
A(\mathtt{Uint16Array}), A(\mathtt{Int16Array}) & = & \arr{16}{\intsm} \\
A(\mathtt{Uint32Array}), A(\mathtt{Int32Array}) & = & \arr{32}{\intsm} \\
A(\mathtt{Float32Array})                        & = & \arr{32}{\doublesm} \\
A(\mathtt{Float64Array})                        & = & \arr{64}{\doublesm} \\
\end{array}
\]

\[
\begin{array}{rcc@{\ }l}
\mathjs{+}, \mathjs{-}
                 & : &       & \funty{\double, \double}{\double} \\
                 &   & \land & \funty{\int, \int}{\intish} \\
\mathjs{*}       & : &       & \funty{\double, \double}{\double} \\
\mathjs{/}, \mathjs{\%}
                 & : &       & \funty{\double, \double}{\double} \\
                 &   & \land & \funty{\signed, \signed}{\intish}  \\
                 &   & \land & \funty{\unsigned, \unsigned}{\intish} \\
\\
\mathjs{|}, \mathjs{\&}, \mathjs{\^{}}, \mathjs{<<}, \mathjs{>>}
                 & : &       & \funty{\intish, \intish}{\signed} \\
\mathjs{>>>}     & : &       & \funty{\intish, \intish}{\unsigned} \\
\\
\mathjs{<}, \mathjs{<=}, \mathjs{>}, \mathjs{>=}, \mathjs{==}, \mathjs{!=}
                 & : &       & \funty{\signed, \signed}{\bit} \\
                 &   & \land & \funty{\unsigned, \unsigned}{\bit} \\
                 &   & \land & \funty{\double, \double}{\bit} \\
\\
\mathjs{+}       & : &       & \funty{\intish}{\double} \\
\mathjs{\~{}}    & : &       & \funty{\intish}{\signed} \\
\mathjs{!}       & : &       & \funty{\boolish}{\bit} \\
\end{array}
\]

\[
\Gamma ::= \{ \seq{x : \rho} \} ~|~ \Gamma, \{ \seq{x : \rho} \}
\]

\[
\begin{array}{lr}
\mbox{Program checking} & \hfil \fbox{$\progjudge{P}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Program}]
  {\{ \seq{x} \} \cap \{ \seq{f} \} = \emptyset \\
   \{ \seq{x} \} \cap \{ [g], [e], [b] \} = \emptyset \\
   \{ \seq{f} \} \cap \{ [g], [e], [b] \} = \emptyset \\\\
   \forall i . \impjudge{[e]}{[b]}{\Gamma_0}{\mathit{imp}_x} \\
   \forall i . \fnjudge{\Gamma_0, \Gamma_1}{\mathit{fn}_f} \\
   \forall i . \expjudge{\Gamma_0, \Gamma_1}{\mathit{exp}}}
  {\progjudge{\fun{[g]}{[e[, b]]}{\seq{\mathit{imp}_x}\ \seq{\mathit{fn}_f}\ \mathit{exp}}}}
\end{array}
}
\\ \\
\mbox{Import checking} & \hfil \fbox{$\impjudge{[e]}{[b]}{\Gamma}{\mathit{imp}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-ImportStd}]
  {\Gamma(x) = M(y)}
  {\impjudge{e}{[b]}{\Gamma}{\var{x \mathjs{ = } e\mathjs{.}y}}}
\qquad
\inferrule* [lab=\rel{T-ImportFFI}]
  {y \not\in\dom(M), \dom(A) \\
   \Gamma(x) = \function}
  {\impjudge{e}{[b]}{\Gamma}{\var{x \mathjs{ = } e\mathjs{.}y}}}
\\ \\
\inferrule* [lab=\rel{T-NewView}]
  {\Gamma(x) = \arr{n}{A(y)}}
  {\impjudge{e}{b}{\Gamma}{\var{x \mathjs{ = new } e\mathjs{.}y(b)}}}
\end{array}
}
\\ \\
\mbox{Function checking} & \hfil \fbox{$\fnjudge{\Gamma}{\mathit{fn}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Function}]
  {\{ \seq{x} \} \cap \{ \seq{y} \} = \emptyset \\
   \Gamma(f) = \funty{\seq{\sigma}}{\tau} \\
   \seq{\sigma} = \seq{\type(\kappa_x)} \\
   \tau \not= \void \\\\
   \stmtjudge{\Gamma, \{ \seq{x : \sigma}, \seq{y : \type(v)} \}}{\emptyset}{\mathit{ss}}{\tau}{\mustret}}
  {\fnjudge{\Gamma}{\fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \var{\seq{y\mathjs{ = }v}}\ \mathit{ss}}}}
\\ \\
\inferrule* [lab=\rel{T-VoidFunction}]
  {\{ \seq{x} \} \cap \{ \seq{y} \} = \emptyset \\
   \Gamma(f) = \funty{\seq{\sigma}}{\void} \\
   \seq{\sigma} = \seq{\type(\kappa_x)} \\\\
   \stmtjudge{\Gamma, \{ \seq{x : \sigma}, \seq{y : \type(v)} \}}{\emptyset}{\mathit{ss}}{\void}{\varepsilon}}
  {\fnjudge{\Gamma}{\fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \var{\seq{y\mathjs{ = }v}}\ \mathit{ss}}}}
\end{array}
}
\\ \\
\mbox{Export checking} & \hfil \fbox{$\expjudge{\Gamma}{\mathit{exp}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
%% FIXME: args should be <: jsval as well
\inferrule* [lab=\rel{T-Singleton}]
  {\Gamma(f) = \funty{\seq{\sigma}}{\tau} \\
   \tau <: \extern }
  {\expjudge{\Gamma}{\return{f}}}
\qquad
\inferrule* [lab=\rel{T-Module}]
  {\forall f . (\Gamma(f) = \funty{\seq{\sigma}}{\tau} \land
   \tau <: \extern)}
  {\expjudge{\Gamma}{\return{\mathjs{\char123{} } \seq{x \mathjs{:} f} \mathjs{ \char125{}}}}}
\end{array}
}
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Statement list checking} & \hfil \fbox{$\stmtjudge{\Gamma}{L}{\mathit{ss}}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-NoStatements}]
  { }
  {\stmtjudge{\Gamma}{L}{\epsilon}{\tau}{\emptyset}}
\qquad
\inferrule* [lab=\rel{T-Statements}]
  {\forall i . \stmtjudge{\Gamma}{L}{s_i}{\tau}{\varepsilon_i} \\\\
   n > 0 \\
   \varepsilon = \varepsilon_1 \seqcomp \ldots \seqcomp \varepsilon_n}
  {\stmtjudge{\Gamma}{L}{\seq{s}}{\tau}{\varepsilon}}
\end{array}
}
\\ \\
\mbox{Statement checking} & \hfil \fbox{$\stmtjudge{\Gamma}{L}{s}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Block}]
  {\stmtjudge{\Gamma}{\emptyset}{\mathit{ss}}{\tau}{\varepsilon}}
  {\stmtjudge{\Gamma}{L}{\block{\mathit{ss}}}{\tau}{\varepsilon}}
\qquad
\inferrule* [lab=\rel{T-ExprStmt}]
  {\exprjudge{\Gamma}{e}{\sigma}}
  {\stmtjudge{\Gamma}{L}{e\mathjs{;}}{\tau}{\emptyset}}
\\ \\
\inferrule* [lab=\rel{T-If}]
  {\exprjudge{\Gamma}{e}{\boolish} \\\\
   \stmtjudge{\Gamma}{\emptyset}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \varepsilon \cup \emptyset}
  {\stmtjudge{\Gamma}{L}{\ifthen{e}{s}}{\tau}{\varepsilon'}}
\qquad
\inferrule* [lab=\rel{T-IfElse}]
  {\exprjudge{\Gamma}{e}{\boolish} \\\\
   \stmtjudge{\Gamma}{\emptyset}{s_1}{\tau}{\varepsilon_1} \\
   \stmtjudge{\Gamma}{\emptyset}{s_2}{\tau}{\varepsilon_2} \\\\
   \varepsilon = \varepsilon_1 \cup \varepsilon_2}
  {\stmtjudge{\Gamma}{L}{\ifthenelse{e}{s_1}{s_2}}{\tau}{\varepsilon}}
\\ \\
\inferrule* [lab=\rel{T-ReturnExpr}]
  {\type(e) <: \tau \\
   \exprjudge{\Gamma}{e}{\tau}}
  {\stmtjudge{\Gamma}{L}{\return{e}}{\tau}{\mustret}}
\qquad
\inferrule* [lab=\rel{T-ReturnVoid}]
  { }
  {\stmtjudge{\Gamma}{L}{\mathtt{return;}}{\void}{\mustret}}
\\ \\
\inferrule* [lab=\rel{T-While}]
  {\exprjudge{\Gamma}{e}{\boolish} \\\\
   \stmtjudge{\Gamma}{L \cup \{ \epsilon \}}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \emptyset \cup \varepsilon - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\while{e}{s}}{\tau}{\varepsilon'}}
\qquad
\inferrule* [lab=\rel{T-DoWhile}]
  {\stmtjudge{\Gamma}{L \cup \{ \epsilon \}}{s}{\tau}{\varepsilon} \\\\
   \exprjudge{\Gamma}{e}{\boolish} \\\\
   \varepsilon' = \varepsilon - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\dowhile{s}{e}}{\tau}{\varepsilon'}}
\\ \\
\inferrule* [lab=\rel{T-For}]
  {[\exprjudge{\Gamma}{e_1}{\sigma_1}] \\
   [\exprjudge{\Gamma}{e_2}{\boolish}] \\
   [\exprjudge{\Gamma}{e_3}{\sigma_3}] \\\\
   \stmtjudge{\Gamma}{L \cup \{ \epsilon \}}{s}{\tau}{\varepsilon} \\
   \varepsilon' = \emptyset \cup \varepsilon - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\for{[e_1]}{[e_2]}{[e_3]}{s}}{\tau}{\varepsilon'}}
\end{array}
}
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Statement checking (cont'd)} & \hfil \fbox{$\stmtjudge{\Gamma}{L}{s}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Break}]
  { }
  {\stmtjudge{\Gamma}{L}{\brk}{\tau}{\{ \epsilon \}}}
\qquad
\inferrule* [lab=\rel{T-BreakLabel}]
  { }
  {\stmtjudge{\Gamma}{L}{\brkl{\mathit{lab}}}{\tau}{\{ \mathit{lab} \}}}
\\ \\
\inferrule* [lab=\rel{T-Continue}]
  { }
  {\stmtjudge{\Gamma}{L}{\cont}{\tau}{\emptyset}}
\qquad
\inferrule* [lab=\rel{T-ContinueLabel}]
  { }
  {\stmtjudge{\Gamma}{L}{\contl{\mathit{lab}}}{\tau}{\emptyset}}
\\ \\
\inferrule* [lab=\rel{T-Label}]
  {\stmtjudge{\Gamma}{L \cup \{ \mathit{lab} \}}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \varepsilon - (L \cup \{ \mathit{lab} \})}
  {\stmtjudge{\Gamma}{L}{\lab{\mathit{lab}}{s}}{\tau}{\varepsilon'}}
\\ \\
%% FIXME: add rule to handle empty switch
\inferrule* [lab=\rel{T-Switch}]
  {\exprjudge{\Gamma}{e}{\sigma} \\\\
   \forall i . \casejudge{\Gamma}{L \cup \{ \epsilon \}}{c_i}{\sigma}{\tau}{\varepsilon_i} \\\\
   \casejudge{\Gamma}{L \cup \{ \epsilon \}}{\mathit{cd}}{\sigma}{\tau}{\varepsilon} \\\\
   \varepsilon \not= \mustret \lor \exists i . \varepsilon_i \cup \emptyset \not= \emptyset \\\\
   \varepsilon' = (\varepsilon \cup \bigcup_i \varepsilon_i) - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\switch{e}{\seq{c}\ \mathit{cd}}}{\tau}{\varepsilon'}}
\qquad
\inferrule* [lab=\rel{T-SwitchReturn}]
  {\exprjudge{\Gamma}{e}{\sigma} \\\\
   \forall i . \casejudge{\Gamma}{L \cup \{ \epsilon \}}{c_i}{\sigma}{\tau}{\varepsilon_i} \\\\
   \forall i . \varepsilon_i \cup \emptyset = \emptyset \\\\
   \casejudge{\Gamma}{L \cup \{ \epsilon \}}{\mathit{cd}}{\sigma}{\tau}{\mustret}}
  {\stmtjudge{\Gamma}{L}{\switch{e}{\seq{c}\ \mathit{cd}}}{\tau}{\mustret}}
\\ \\
\inferrule* [lab=\rel{T-EmptySwitch}]
  {\exprjudge{\Gamma}{e}{\sigma}}
  {\stmtjudge{\Gamma}{L}{\switch{e}{}}{\tau}{\emptyset}}
\qquad
\inferrule* [lab=\rel{T-EmptyStatement}]
  { }
  {\stmtjudge{\Gamma}{L}{\mathjs{;}}{\tau}{\emptyset}}
\end{array}
}
\\ \\
\mbox{Case checking} & \hfil \fbox{$\casejudge{\Gamma}{L}{\mathit{cd}}{\sigma}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Case}]
  {\exprjudge{\Gamma}{e}{\sigma} \\\\
   \stmtjudge{\Gamma}{L}{\mathit{ss}}{\tau}{\varepsilon}}
  {\casejudge{\Gamma}{L}{\mathjs{case }e\mathjs{:}\,\mathit{ss}}{\sigma}{\tau}{\varepsilon}}
\qquad
\inferrule* [lab=\rel{T-Default}]
  {\stmtjudge{\Gamma}{L}{\mathit{ss}}{\tau}{\varepsilon}}
  {\casejudge{\Gamma}{L}{\mathjs{default:}\,\mathit{ss}}{\sigma}{\tau}{\varepsilon}}
\end{array}
}
\end{array}
\]

%% FIXME: add update operators (+=, ++, etc)

\[
\begin{array}{lr}
\mbox{Expression checking} & \hfil \fbox{$\exprjudge{\Gamma}{e}{\tau}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Constant}]
  {-2^{31} \leq n < 2^{32}}
  {\exprjudge{\Gamma}{n}{\constant}}
\qquad
\inferrule* [lab=\rel{T-Double}]
  { }
  {\exprjudge{\Gamma}{r}{\double}}
\\ \\
\inferrule* [lab=\rel{T-VarRef}]
  {\Gamma(x) = \tau}
  {\exprjudge{\Gamma}{x}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Assign}]
  {\exprjudge{\Gamma}{e}{\tau} \\
   \tau <: \Gamma(x)}
  {\exprjudge{\Gamma}{x\mathjs{ = }e}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-Load}]
  {m = 2^k - 1 \\\\
   \Gamma(x) = \arr{n}{\tau} \\
   \exprjudge{\Gamma}{e}{\intish}}
  {\exprjudge{\Gamma}{\getprop{x}{\paren{e\mathjs{ \& } m}\mathjs{ >> }n/8}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Store}]
  {m = 2^k - 1 \\
   \Gamma(x) = \arr{n}{\tau} \\\\
   \exprjudge{\Gamma}{e_1}{\intish} \\
   \exprjudge{\Gamma}{e_2}{\tau}}
  {\exprjudge{\Gamma}{\getprop{x}{\paren{e_1\mathjs{ \& } m}\mathjs{ >> }n/8}\mathjs{ = }e_2}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-IMul}]
  {\Gamma(f) = \imul \\\\
   \forall i . \exprjudge{\Gamma}{e_i}{\intish}}
  {\exprjudge{\Gamma}{\funcall{f}{e_1, e_2}}{\signed}}
\qquad
\inferrule* [lab=\rel{T-FunCall}]
  {\Gamma(f) = \_ \land \funty{\seq{\sigma}}{\tau} \land \_ \\\\
   \forall i . \exprjudge{\Gamma}{e_i}{\sigma_i}}
  {\exprjudge{\Gamma}{\funcall{f}{\seq{e}}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-FFI}]
  {\Gamma(f) = \function \\\\
   \forall i . \exprjudge{\Gamma}{e_i}{\extern}}
  {\exprjudge{\Gamma}{\funcall{f}{\seq{e}}}{\unk}}
\\ \\
\inferrule* [lab=\rel{T-Conditional}]
  {\exprjudge{\Gamma}{e_1}{\boolish} \\\\
   \exprjudge{\Gamma}{e_2}{\tau} \\
   \exprjudge{\Gamma}{e_3}{\tau}}
  {\exprjudge{\Gamma}{\ternary{e_1}{e_2}{e_3}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Paren}]
  {\forall i \leq n . \exprjudge{\Gamma}{e_i}{\tau_i}}
  {\exprjudge{\Gamma}{\paren{\seq{e}}}{\tau_n}}
\\ \\
\inferrule* [lab=\rel{T-Unop}]
  {\mathit{unop} : \_ \land \funty{\sigma}{\tau} \land \_ \\
   \exprjudge{\Gamma}{e}{\sigma}}
  {\exprjudge{\Gamma}{\mathit{unop}\ e}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Binop}]
  {\mathit{binop} : \_ \land \funty{\sigma_1, \sigma_2}{\tau} \land \_ \\\\
   \exprjudge{\Gamma}{e_1}{\sigma_1} \\
   \exprjudge{\Gamma}{e_2}{\sigma_2}}
  {\exprjudge{\Gamma}{e_1\ \mathit{binop}\ e_2}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-Sub}]
  {\exprjudge{\Gamma}{e}{\sigma} \\
   \sigma <: \tau}
  {\exprjudge{\Gamma}{e}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Cast}]
  {\exprjudge{\Gamma}{e}{\double}}
  {\exprjudge{\Gamma}{\mathjs{\~{}\~{}}e}{\signed}}
\end{array}
}
\end{array}
\]

\end{document}
