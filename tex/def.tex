\documentclass{article}

\usepackage{mathpartir}
\usepackage{amssymb}

\newcommand{\ternary}[3]{{#1}\ \mathjs{?}\ {#2}\ \mathjs{:}\ {#3}}
\newcommand{\funcall}[2]{{#1}\mathjs{(}{#2}\mathjs{)}}
\newcommand{\paren}[1]{\mathjs{(}{#1}\mathjs{)}}
\newcommand{\dom}{\mathit{dom}}
\newcommand{\type}{\mathit{type}}
\newcommand{\funty}[2]{({#1}) \rightarrow {#2}}
\newcommand{\seq}[1]{\overline{{#1}}}
\newcommand{\mathjs}[1]{\mbox{\texttt{{#1}}}}
\newcommand{\mathjssm}[1]{\mbox{\texttt{\scriptsize {#1}}}}
\newcommand{\return}[1]{\mathjs{return }{#1}\mathjs{;}}
\newcommand{\fun}[3]{\mathjs{function }{#1}\mathjs{(}{#2}\mathjs{) \char123{} }{#3}\mathjs{ \char125{}}}
\newcommand{\afun}[2]{\mathjs{function}\mathjs{(}{#1}\mathjs{) \char123{} }{#2}\mathjs{ \char125{}}}
\newcommand{\var}[1]{\mathjs{var }{#1}\mathjs{;}}
\newcommand{\rel}[1]{\scriptsize [\textsc{#1}]}
\newcommand\defeq{\stackrel{\mbox{\tiny def}}{=}}
\newcommand{\while}[2]{\mathjs{while (}{#1}\mathjs{) }{#2}}
\newcommand{\dowhile}[2]{\mathjs{do }{#1}\mathjs{ while (}{#2}\mathjs{);}}
\newcommand{\for}[4]{\mathjs{for (}{#1}\mathjs{; }{#2}\mathjs{; }{#3}\mathjs{) }{#4}}
\newcommand{\switch}[2]{\mathjs{switch (}{#1}\mathjs{) \char123{} }{#2}\mathjs{ \char125{}}}
\newcommand{\switchdef}[3]{\mathjs{switch (}{#1}\mathjs{) \char123{} }{#2}\mathjs{ default:}\,{#3}\mathjs{ \char125{}}}
\newcommand{\brk}{\mathjs{break;}}
\newcommand{\brkl}[1]{\mathjs{break }{#1}\mathjs{;}}
\newcommand{\cont}{\mathjs{continue;}}
\newcommand{\contl}[1]{\mathjs{continue }{#1}\mathjs{;}}
\newcommand{\lab}[2]{{#1}\mathjs{:}\,{#2}}
\newcommand{\ifthen}[2]{\mathjs{if (}{#1}\mathjs{) }{#2}}
\newcommand{\ifthenelse}[3]{\mathjs{if (}{#1}\mathjs{) }{#2}\mathjs{ else }{#3}}
\newcommand{\block}[1]{\mathjs{\char123{} }{#1}\mathjs{ \char125{}}}
\newcommand{\ok}{\mathrm{\mathbf{ok}}}
\newcommand{\rulebreak}{\vspace{.1in}\\}
\newcommand{\bit}{\mathtt{bit}}
\newcommand{\unsigned}{\mathtt{unsigned}}
\newcommand{\intsm}{\mathjssm{int}}
\newcommand{\doublesm}{\mathjssm{double}}
\newcommand{\signed}{\mathtt{signed}}
\newcommand{\constant}{\mathtt{constant}}
\newcommand{\double}{\mathtt{double}}
\newcommand{\view}[2]{\mathtt{view}^{#1}_{#2}}
\newcommand{\extern}{\mathtt{extern}}
\newcommand{\unk}{\mathtt{unknown}}
\newcommand{\str}{\mathtt{string}}
\newcommand{\undef}{\mathtt{undefined}}
\newcommand{\void}{\mathtt{void}}
\newcommand{\nul}{\mathtt{null}}
\newcommand{\num}{\mathtt{number}}
\newcommand{\obj}{\mathtt{object}}
\newcommand{\mustret}{\mathsf{return}}
\newcommand{\seqcomp}{\mathrel{;}}
\newcommand{\getprop}[2]{{#1}\mathjs{[}{#2}\mathjs{]}}
\newcommand{\getpropsm}[2]{{#1}\mathjssm{[}{#2}\mathjssm{]}}
\newcommand{\longlong}[2]{\mathjs{[}{#1},{#2}\mathjs{]}}
\newcommand{\toint}[1]{\mathjs{\~{}\~{}}{#1}}
\newcommand{\todouble}[1]{\mathjs{+}{#1}}
\renewcommand{\int}{\mathtt{int}}
\newcommand{\dword}{\mathtt{bits64}}
\newcommand{\function}{\mathtt{function}}
\newcommand{\union}[2]{{#1}\mathrel{|}{#2}}
\newcommand{\boolish}{\mathtt{boolish}}
\newcommand{\floor}{\mathtt{floor}}
\newcommand{\imul}{\mathtt{imul}}
\newcommand{\intish}{\mathtt{intish}}

\newcommand{\progjudge}[1]{\vdash {#1}\ \ok}
\newcommand{\impjudge}[4]{{#1};{#2};{#3} \vdash {#4}\ \ok}
\newcommand{\fnjudge}[2]{{#1} \vdash {#2}\ \ok}
\newcommand{\expjudge}[2]{{#1} \vdash {#2}\ \ok}
\newcommand{\stmtjudge}[5]{{#1};{#2} \vdash {#3} : {#4} / {#5}}
\newcommand{\exprjudge}[4]{{#1};{#2} \vdash {#3} : {#4}}
\newcommand{\stmtretjudge}[2]{\vdash {#1} \hookrightarrow {#2}}
\newcommand{\sjudge}[4]{{#1};{#2};{#3} \vdash {#4}\ \ok}

\newcommand{\returns}{\mathit{returns}}
\newcommand{\breaks}{\mathit{breaks}}

\begin{document}

\title{\texttt{asm.js}}
\author{Dave Herman, Luke Wagner, and Alon Zakai}
\maketitle

\section{Abstract syntax}

\[
\begin{array}{rcl}
b, e, f, g, x, y, z               & \in & \mathit{Identifier} \\
\mathtt{arguments}, \mathtt{eval} & \not\in & \mathit{Identifier} \\
\end{array}
\]

\[
\begin{array}{rcl}
P               & ::= & \fun{[g]}{[e[, b]]}{\mathjs{"use asm"; } \seq{\mathit{imp}_x}\ \seq{\mathit{fn}_f}\ \seq{\var{\seq{y \mathjs{ = } v}}}\ \mathit{exp}} \\
\mathit{imp}_x  & ::= & \var{x \mathjs{ = } e\mathjs{.}y} \\
                &  |  & \var{x \mathjs{ = } \mathjs{new }\funcall{e\mathjs{.}y}{b}} \\
\mathit{exp}    & ::= & \return{f} \\
                &  |  & \return{\mathjs{\char123{} } \seq{x \mathjs{:} f} \mathjs{ \char125{}}} \\
\mathit{fn}_f   & ::= & \fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \seq{\var{\seq{y\mathjs{ = }v}}}\ \mathit{ss}} \\
\end{array}
\]

\[
\begin{array}{rcl}
s & ::= & \block{\mathit{ss}} \\
  &  |  & e\mathjs{;} \\
  &  |  & \mathjs{;} \\
  &  |  & \ifthen{e}{s} \\
  &  |  & \ifthenelse{e}{s}{s} \\
  &  |  & \return{[e]} \\
  &  |  & \while{e}{s} \\
  &  |  & \dowhile{s}{e} \\
  &  |  & \for{[e]}{[e]}{[e]}{s} \\
  &  |  & \switch{e}{\seq{c}\ [d]} \\
  &  |  & \brkl{[\mathit{lab}]} \\
  &  |  & \contl{[\mathit{lab}]} \\
  &  |  & \lab{\mathit{lab}}{s} \\
\\
\mathit{ss} & ::= & \seq{s} \\
\\
c & ::= & \mathjs{case }v\mathjs{:}\,\mathit{ss} \\
d & ::= & \mathjs{default:}\,\mathit{ss} \\
\mathit{cd} & ::= & c ~|~ d \\
\end{array}
\]

\[
\kappa_x ::= \toint{x} ~|~ \todouble{x} ~|~ x\mathjs{|0} ~|~ x\mathjs{>>>0} \\
\]

\[
\begin{array}{rcl}
v & ::= & r ~|~ n \\
\\
e & ::= & v \\
  &  |  & \mathit{lval} \\
  &  |  & \mathit{lval}\mathjs{ = }e \\
  &  |  & \funcall{f}{\seq{e}} \\
  &  |  & \mathit{unop}\ e \\
  &  |  & e\ \mathit{binop}\ e \\
  &  |  & \ternary{e}{e}{e} \\
  &  |  & \paren{\seq{e}} \\
\\
\mathit{unop} & ::= & \mathjs{+} ~|~ \mathjs{\~{}} ~|~ \mathjs{!} \\
\\
\mathit{binop} & ::= & \mathjs{+} ~|~ \mathjs{-} ~|~ \mathjs{*} ~|~ \mathjs{/} ~|~ \mathjs{\%} \\
               &  |  & \mathjs{|} ~|~ \mathjs{\&} ~|~ \mathjs{\^{}} ~|~ \mathjs{<<} ~|~ \mathjs{>>} ~|~ \mathjs{>>>} \\
               &  |  & \mathjs{<} ~|~ \mathjs{<=} ~|~ \mathjs{>} ~|~ \mathjs{>=} ~|~ \mathjs{!=} ~|~ \mathjs{==} \\
\mathit{lval} & ::= & x ~|~ \getprop{x}{\paren{e\mathjs{ \& }m}\mathjs{ >> }n} \\
\end{array}
\]

\section{Type rules}

\[
\begin{array}{rcl}
\sigma, \tau & ::= & \bit ~|~ \double ~|~ \int ~|~ \signed ~|~ \unsigned ~|~ \boolish ~|~ \intish ~|~ \void ~|~ \unk \\
\rho & ::= & \tau ~|~ \view{n}{\tau} ~|~ \imul ~|~ \function ~|~ \funty{\seq{\sigma}}{\tau} \\
\omega & ::= & (\funty{\seq{\sigma}}{\tau}) \land \ldots \land (\funty{\seq{\sigma'}}{\tau'}) \\
\end{array}
\]

%% \[
%% \begin{array}{rcl}
%% \ell        & ::= & \mathit{lab} ~|~ \epsilon \\
%% L           & ::= & \{ \seq{\ell} \} \\
%% \varepsilon & ::= & L ~|~ \mustret \\
%% \end{array}
%% \]

%% \[
%% \begin{array}{rcl}
%% L                       \seqcomp L'       & = & L \cup L' \\
%% \emptyset               \seqcomp \mustret & = & \mustret \\
%% \{ \ell, \seq{\ell'} \} \seqcomp \mustret & = & \{ \ell, \seq{\ell'} \} \\
%% \mustret                \seqcomp L        & = & \mustret \\
%% \end{array}
%% \]

%% \[
%% \begin{array}{rcl}
%% L        \cup \mustret & = & L \\
%% \mustret \cup L        & = & L \\
%% \mustret \cup \mustret & = & \mustret \\
%% \end{array}
%% \]

\[
\begin{array}{rcl}
\type(\toint{X})      & = & \int \\
\type(\todouble{X})   & = & \double \\
\type(n)              & = & \int \\
\type(r)              & = & \double \\
\type(X\mathjs{|0})   & = & \signed \\
\type(X\mathjs{>>>0}) & = & \unsigned \\
\end{array}
\]

%% NOTE: pure pointers will not be jsval

\[
\begin{array}{rcl}
\constant                                                                           & <: & \signed, \unsigned \\
\signed, \unsigned                                                                  & <: & \int, \extern \\
\bit, \int                                                                          & <: & \boolish \\
\double                                                                             & <: & \extern \\
\unk, \int                                                                          & <: & \intish \\
\end{array}
\]

\[
\begin{array}{rcl}
M(\imul) & : & \imul \\
M(\mathtt{ceil}), M(\mathtt{sin}), M(\mathtt{cos}) & : & \funty{\double}{\double} \\
\end{array}
\]

\[
\begin{array}{rcl}
A(\mathtt{Uint8Array}), A(\mathtt{Int8Array})   & = & \view{8}{\intsm} \\
A(\mathtt{Uint16Array}), A(\mathtt{Int16Array}) & = & \view{16}{\intsm} \\
A(\mathtt{Uint32Array}), A(\mathtt{Int32Array}) & = & \view{32}{\intsm} \\
A(\mathtt{Float32Array})                        & = & \view{32}{\doublesm} \\
A(\mathtt{Float64Array})                        & = & \view{64}{\doublesm} \\
\end{array}
\]

\[
\begin{array}{rcc@{\ }l}
\mathjs{+}, \mathjs{-}
                 & : &       & \funty{\double, \double}{\double} \\
                 &   & \land & \funty{\int, \int}{\intish} \\
\mathjs{*}       & : &       & \funty{\double, \double}{\double} \\
\mathjs{/}, \mathjs{\%}
                 & : &       & \funty{\double, \double}{\double} \\
                 &   & \land & \funty{\signed, \signed}{\intish}  \\
                 &   & \land & \funty{\unsigned, \unsigned}{\intish} \\
\\
\mathjs{|}, \mathjs{\&}, \mathjs{\^{}}, \mathjs{<<}, \mathjs{>>}
                 & : &       & \funty{\intish, \intish}{\signed} \\
\mathjs{>>>}     & : &       & \funty{\intish, \intish}{\unsigned} \\
\\
\mathjs{<}, \mathjs{<=}, \mathjs{>}, \mathjs{>=}, \mathjs{==}, \mathjs{!=}
                 & : &       & \funty{\signed, \signed}{\bit} \\
                 &   & \land & \funty{\unsigned, \unsigned}{\bit} \\
                 &   & \land & \funty{\double, \double}{\bit} \\
\\
\mathjs{+}       & : &       & \funty{\intish}{\double} \\
\mathjs{\~{}}    & : &       & \funty{\intish}{\signed} \\
\mathjs{!}       & : &       & \funty{\boolish}{\bit} \\
\end{array}
\]

\[
\begin{array}{rcl}
\Delta & ::= & \{ \seq{x : \rho} \} \\
\Gamma & ::= & \{ \seq{x : \tau} \} \\
\end{array}
\]

\[
\begin{array}{rcl}
\breaks(\seq{s}) & = & \bigcup_i \breaks(s_i) \\
\breaks(\block{\mathit{ss}}) & = & \breaks(\mathit{ss}) \\
\breaks(\ifthen{e}{s}) & = & \breaks(s) \\
\breaks(\ifthenelse{e}{s_1}{s_2}) & = & \breaks(s_1) \cup \breaks(s_2) \\
\breaks(\while{e}{s}) & = & \breaks(s) - \{ \epsilon \} \\
\breaks(\dowhile{s}{e}) & = & \breaks(s) - \{ \epsilon \} \\
\breaks(\for{[e_1]}{[e_2]}{[e_3]}{s}) & = & \breaks(s) - \{ \epsilon \} \\
\breaks(\brk) & = & \{ \epsilon \} \\
\breaks(\brkl{\mathit{lab}}) & = & \{ \mathit{lab} \} \\
\breaks(\lab{\mathit{lab}}{s}) & = & \breaks(s) - \{ \mathit{lab} \} \\
\breaks(\switch{e}{\seq{\mathit{cd}}}) & = & \bigcup_i \breaks(\mathit{cd}_i) - \{ \epsilon \} \\
\breaks(s) \mbox{ (otherwise)} & = & \emptyset \\
\breaks(\mathjs{case }v\mathjs{:}\,\mathit{ss}) & = & \breaks(\mathit{ss}) \\
\breaks(\mathjs{default:}\,\mathit{ss}) & = & \breaks(\mathit{ss}) \\
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Program checking} & \hfil \fbox{$\progjudge{P}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Program}]
  {\seq{x}, \seq{y}, \seq{f}, [g], [e], [b]\ \mbox{distinct} \\
   \forall y . \Delta(y) = \type(v) \\\\
   \forall i . \impjudge{[e]}{[b]}{\Delta}{\mathit{imp}_x} \\
   \forall i . \fnjudge{\Delta}{\mathit{fn}_f} \\
   \forall i . \expjudge{\Delta}{\mathit{exp}}}
  {\progjudge{\fun{[g]}{[e[, b]]}{\mathjs{"use asm";}\ \seq{\mathit{imp}_x}\ \seq{\mathit{fn}_f}\ \seq{\var{\seq{y \mathjs{ = } v}}}\ \mathit{exp}}}}
\end{array}
}
\\ \\
\mbox{Import checking} & \hfil \fbox{$\impjudge{[e]}{[b]}{\Delta}{\mathit{imp}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-ImportStd}]
  {\Delta(x) = M(y)}
  {\impjudge{e}{[b]}{\Delta}{\var{x \mathjs{ = } e\mathjs{.}y}}}
\qquad
\inferrule* [lab=\rel{T-ImportFFI}]
  {y \not\in\dom(M), \dom(A) \\
   \Delta(x) = \function}
  {\impjudge{e}{[b]}{\Delta}{\var{x \mathjs{ = } e\mathjs{.}y}}}
\\ \\
\inferrule* [lab=\rel{T-View}]
  {\Delta(x) = \view{n}{A(y)}}
  {\impjudge{e}{b}{\Delta}{\var{x \mathjs{ = new } e\mathjs{.}y(b)}}}
\end{array}
}
\\ \\
\mbox{Function checking} & \hfil \fbox{$\fnjudge{\Delta}{\mathit{fn}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Function}]
  {\seq{x}, \seq{y}\ \mbox{distinct} \\
   \Delta(f) = \funty{\seq{\sigma}}{\tau} \\
   \seq{\sigma} = \seq{\type(\kappa_x)} \\\\
   %% \tau \not= \void \\\\
   %% \stmtjudge{\Delta}{\{ \seq{x : \sigma}, \seq{y : \type(v)} \}}{\mathit{ss}}{\tau}{\mustret}}
   \sjudge{\Delta}{\{\seq{x: \sigma}, \seq{y : \type(v)}\}}{f}{\mathit{ss}} \\
   \tau \not=\void \Rightarrow \returns(\mathit{ss})}
  {\fnjudge{\Delta}{\fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \seq{\var{\seq{y\mathjs{ = }v}}}\ \mathit{ss}}}}
%% \\ \\
%% \inferrule* [lab=\rel{T-VoidFunction}]
%%   {\seq{x}, \seq{y}\ \mbox{distinct} \\
%%    \Delta(f) = \funty{\seq{\sigma}}{\void} \\
%%    \seq{\sigma} = \seq{\type(\kappa_x)} \\\\
%%    \stmtjudge{\Delta}{\{ \seq{x : \sigma}, \seq{y : \type(v)} \}}{\mathit{ss}}{\void}{\varepsilon}}
%%   {\fnjudge{\Delta}{\fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \seq{\var{\seq{y\mathjs{ = }v}}}\ \mathit{ss}}}}
\end{array}
}
\\ \\
\mbox{Export checking} & \hfil \fbox{$\expjudge{\Delta}{\mathit{exp}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Singleton}]
  {\Delta(f) = \funty{\seq{\sigma}}{\tau} \\
   \tau <: \extern }
  {\expjudge{\Delta}{\return{f}}}
\qquad
\inferrule* [lab=\rel{T-Module}]
  {\forall f . \Delta(f) = \funty{\seq{\sigma}}{\tau} \land
   \tau <: \extern}
  {\expjudge{\Delta}{\return{\mathjs{\char123{} } \seq{x \mathjs{:} f} \mathjs{ \char125{}}}}}
\end{array}
}
\end{array}
\]

\newsavebox{\switchcontrol}
\begin{lrbox}{\switchcontrol}
\begin{minipage}[t]{2.87in}
\vspace{-.25in}
\[
\varepsilon = \left\{ \begin{array}{ll}
                      \mustret & \mbox{if}\ \varepsilon_n = \mustret \land \forall i . \varepsilon_i \cup \emptyset = \emptyset \\
                      \bigcup \varepsilon_i - \{ \epsilon \} & \mbox{otherwise}
                      \end{array} \right.
\]
\end{minipage}
\end{lrbox}

\[
\begin{array}{l}
\returns(\seq{s}) \\
\qquad \mbox{if } \returns(s_m) \land \forall i < m . \breaks(s_m) = \emptyset \\
\qquad \mbox{for some } m \\
\returns(\block{\mathit{ss}}) \\
\qquad \mbox{if } \returns(ss) \\
\returns(\ifthenelse{e}{s_1}{s_2}) \\
\qquad \mbox{if } \returns(s_1) \land \returns(s_2) \\
\returns(\dowhile{s}{e}) \\
\qquad \mbox{if } \returns(s) \\
\returns(\switch{e}{\seq{\mathit{cd}}}) \\
\qquad \mbox{if } \returns(cd_n) \land \forall i . \breaks(cd_i) = \emptyset \\
\returns(\mathjs{case }v\mathjs{:}\,\mathit{ss}) \\
\qquad \mbox{if } \returns(\mathit{ss}) \\
\returns(\mathjs{default:}\,\mathit{ss}) \\
\qquad \mbox{if } \returns(\mathit{ss})
\end{array}
\]

%% \[
%% \begin{array}{rcl}
%% \flow(\seq{s}) & = & \flow(s_1) \mathrel{;} \ldots \mathrel{;} flow(s_n) \\
%% \flow(\block{\mathit{ss}}) & = & \flow(\mathit{ss}) \\
%% \flow(e\mathjs{;}) & = & \emptyset \\
%% \flow(\mathjs{;}) & = & \emptyset \\
%% \flow(\return{[e]}) & = & \mustret \\
%% \flow(\ifthen{e}{s}) & = & \flow(s) \cup \emptyset \\
%% \flow(\ifthenelse{e}{s_1}{s_2} & = & \flow(s_1) \cup \flow(s_2) \\
%% \flow(\while{e}{s}) & = & \emptyset \cup \flow(s) - \{ \epsilon \} \\
%% \flow(\dowhile{s}{e}) & = & \flow(s) - \{ \epsilon \} \\
%% \flow(\for{[e_1]}{[e_2]}{[e_3]}{s} & = & \emptyset \cup \flow(s) - \{ \epsilon \} \\
%% \flow(\brk) & = & \{ \epsilon \} \\
%% \flow(\brkl{\mathit{lab}}) & = & \{ \mathit{lab} \} \\
%% \flow(\contl{[\mathit{lab}]}) & = & \emptyset \\
%% \flow(\lab{\mathit{lab}}{s}) & = & \flow(s) - \{ \mathit{lab} \} \\
%% \flow(\switch{e}{\seq{\mathit{cd}}}) & = & \left\{\begin{array}{ll}
%%                                                   \mustret & \mbox{if } \flow(\mathit{cd}_n) = \mustret \\
%%                                                            & \mbox{and } \forall i . \flow(\mathit{cd}_i) \cup \emptyset = \emptyset \\
%%                                                   \bigcup \flow(\mathit{cd}_i) - \{ \epsilon \} & \mbox{otherwise}
%%                                                   \end{array}\right. \\
%% \flow(\mathjs{case }v\mathjs{:}\,\mathit{ss}) & = & \flow(\mathit{ss}) \\
%% \flow(\mathjs{default:}\,\mathit{ss}) & = & \flow(\mathit{ss}) \\
%% \end{array}
%% \]

\[
\begin{array}{lr}
\mbox{Statement list checking} & \hfil \fbox{$\sjudge{\Delta}{\Gamma}{f}{\mathit{ss}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Statements}]
  {\forall i . \sjudge{\Delta}{\Gamma}{f}{s_i}}
  {\sjudge{\Delta}{\Gamma}{f}{\seq{s}}}
\end{array}
}
\\ \\
\mbox{Statement checking} & \hfil \fbox{$\sjudge{\Delta}{\Gamma}{f}{s}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Block}]
  {\sjudge{\Delta}{\Gamma}{f}{\mathit{ss}}}
  {\sjudge{\Delta}{\Gamma}{f}{\block{\mathit{ss}}}}
\qquad
\inferrule* [lab=\rel{T-ExprStmt}]
  {\exprjudge{\Delta}{\Gamma}{e}{\sigma}}
  {\sjudge{\Delta}{\Gamma}{f}{e\mathjs{;}}}
\qquad
\inferrule* [lab=\rel{T-EmptyStatement}]
  { }
  {\sjudge{\Delta}{\Gamma}{f}{\mathjs{;}}}
\\ \\
\inferrule* [lab=\rel{T-If}]
  {\exprjudge{\Delta}{\Gamma}{e}{\boolish} \\\\
   \sjudge{\Delta}{\Gamma}{f}{s}}
  {\sjudge{\Delta}{\Gamma}{f}{\ifthen{e}{s}}}
\qquad
\inferrule* [lab=\rel{T-IfElse}]
  {\exprjudge{\Delta}{\Gamma}{e}{\boolish} \\\\
   \sjudge{\Delta}{\Gamma}{f}{s_1} \\
   \sjudge{\Delta}{\Gamma}{f}{s_2}}
  {\sjudge{\Delta}{\Gamma}{f}{\ifthenelse{e}{s_1}{s_2}}}
\\ \\
\inferrule* [lab=\rel{T-ReturnVar}]
  {\Delta(f) = \funty{\seq{\sigma}}{\tau} \\\\
   \exprjudge{\Delta}{\Gamma}{x}{\tau}}
  {\sjudge{\Delta}{\Gamma}{f}{\return{x}}}
\qquad
\inferrule* [lab=\rel{T-ReturnExpr}]
  {\Delta(f) = \funty{\seq{\sigma}}{\tau} \\\\
   \exprjudge{\Delta}{\Gamma}{e}{\tau} \\
   \type(e) <: \tau}
  {\sjudge{\Delta}{\Gamma}{f}{\return{e}}}
\\ \\
\inferrule* [lab=\rel{T-ReturnVoid}]
  {\Delta(f) = \funty{\seq{\sigma}}{\void}}
  {\sjudge{\Delta}{\Gamma}{f}{\mathtt{return;}}}
\\ \\
\inferrule* [lab=\rel{T-While}]
  {\exprjudge{\Delta}{\Gamma}{e}{\boolish} \\\\
   \sjudge{\Delta}{\Gamma}{f}{s}}
  {\sjudge{\Delta}{\Gamma}{f}{\while{e}{s}}}
\qquad
\inferrule* [lab=\rel{T-DoWhile}]
  {\sjudge{\Delta}{\Gamma}{f}{s} \\\\
   \exprjudge{\Delta}{\Gamma}{e}{\boolish}}
  {\sjudge{\Delta}{\Gamma}{f}{\dowhile{s}{e}}}
\\ \\
\inferrule* [lab=\rel{T-For}]
  {[\exprjudge{\Delta}{\Gamma}{e_1}{\sigma_1}] \\
   [\exprjudge{\Delta}{\Gamma}{e_2}{\boolish}] \\
   [\exprjudge{\Delta}{\Gamma}{e_3}{\sigma_3}] \\\\
   \sjudge{\Delta}{\Gamma}{f}{s}}
  {\sjudge{\Delta}{\Gamma}{f}{\for{[e_1]}{[e_2]}{[e_3]}{s}}}
\\ \\
\inferrule* [lab=\rel{T-Break}]
  { }
  {\sjudge{\Delta}{\Gamma}{f}{\brkl{[\mathit{lab}]}}}
\qquad
\inferrule* [lab=\rel{T-Continue}]
  { }
  {\sjudge{\Delta}{\Gamma}{f}{\contl{[\mathit{lab}]}}}
\\ \\
\inferrule* [lab=\rel{T-Label}]
  {\sjudge{\Delta}{\Gamma}{f}{s}}
  {\sjudge{\Delta}{\Gamma}{f}{\lab{\mathit{lab}}{s}}}
\qquad
\inferrule* [lab=\rel{T-Switch}]
  {\exprjudge{\Delta}{\Gamma}{e}{\sigma} \\
   \sigma <: \extern \\
   \forall i . \type(v_i) <: \sigma \\\\
   \forall i . \sjudge{\Delta}{\Gamma}{f}{\mathit{ss}_i} \\
   [\sjudge{\Delta}{\Gamma}{f}{\mathit{ss}}]}
  {\sjudge{\Delta}{\Gamma}{f}{\switch{e}{\seq{\mathjs{case }v_i\mathjs{:}\,\mathit{ss}_i}\ [\mathjs{default:}\,\mathit{ss}]}}}
\end{array}
}
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Case checking} & \hfil \fbox{$\sjudge{\Delta}{\Gamma}{f}{\mathit{cd}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Case}]
  {\sjudge{\Delta}{\Gamma}{f}{\mathit{ss}}}
  {\sjudge{\Delta}{\Gamma}{f}{\mathjs{case }v\mathjs{:}\,\mathit{ss}}}
\qquad
\inferrule* [lab=\rel{T-Default}]
  {\sjudge{\Delta}{\Gamma}{f}{\mathit{ss}}}
  {\sjudge{\Delta}{\Gamma}{f}{\mathjs{default:}\,\mathit{ss}}}
\end{array}
}
\end{array}
\]

\[
(\Delta\cdot\Gamma)(x) = \left\{\begin{array}{ll}
                                \Gamma(x) & \mbox{if}\ x \in\dom(\Gamma) \\
                                \Delta(x) & \mbox{otherwise}
                                \end{array} \right.
\]

\[
\begin{array}{lr}
\mbox{Expression checking} & \hfil \fbox{$\exprjudge{\Delta}{\Gamma}{e}{\tau}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Constant}]
  {-2^{31} \leq n < 2^{32}}
  {\exprjudge{\Delta}{\Gamma}{n}{\constant}}
\qquad
\inferrule* [lab=\rel{T-Double}]
  { }
  {\exprjudge{\Delta}{\Gamma}{r}{\double}}
\\ \\
\inferrule* [lab=\rel{T-VarRef}]
  {(\Delta\cdot\Gamma)(x) = \tau}
  {\exprjudge{\Delta}{\Gamma}{x}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Assign}]
  {\exprjudge{\Delta}{\Gamma}{e}{\tau} \\
   \tau <: (\Delta\cdot\Gamma)(x)}
  {\exprjudge{\Delta}{\Gamma}{x\mathjs{ = }e}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-Load}]
  {m = 2^k - 1 \\
   (\Delta\cdot\Gamma)(x) = \view{n}{\tau} \\\\
   \exprjudge{\Delta}{\Gamma}{e}{\intish}}
  {\exprjudge{\Delta}{\Gamma}{\getprop{x}{\paren{e\mathjs{ \& } m}\mathjs{ >> }n/8}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Store}]
  {m = 2^k - 1 \\
   (\Delta\cdot\Gamma)(x) = \view{n}{\tau} \\\\
   \exprjudge{\Delta}{\Gamma}{e_1}{\intish} \\
   \exprjudge{\Delta}{\Gamma}{e_2}{\tau}}
  {\exprjudge{\Delta}{\Gamma}{\getprop{x}{\paren{e_1\mathjs{ \& } m}\mathjs{ >> }n/8}\mathjs{ = }e_2}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-IMul}]
  {(\Delta\cdot\Gamma)(f) = \imul \\\\
   \forall i . \exprjudge{\Delta}{\Gamma}{e_i}{\intish}}
  {\exprjudge{\Delta}{\Gamma}{\funcall{f}{e_1, e_2}}{\signed}}
\qquad
\inferrule* [lab=\rel{T-FunCall}]
  {(\Delta\cdot\Gamma)(f) = \funty{\seq{\sigma}}{\tau} \\\\
   \forall i . \exprjudge{\Delta}{\Gamma}{e_i}{\sigma_i}}
  {\exprjudge{\Delta}{\Gamma}{\funcall{f}{\seq{e}}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-FFI}]
  {(\Delta\cdot\Gamma)(f) = \function \\\\
   \forall i . \exprjudge{\Delta}{\Gamma}{e_i}{\extern}}
  {\exprjudge{\Delta}{\Gamma}{\funcall{f}{\seq{e}}}{\unk}}
\\ \\
\inferrule* [lab=\rel{T-Conditional}]
  {\exprjudge{\Delta}{\Gamma}{e_1}{\boolish} \\\\
   \exprjudge{\Delta}{\Gamma}{e_2}{\tau} \\
   \exprjudge{\Delta}{\Gamma}{e_3}{\tau}}
  {\exprjudge{\Delta}{\Gamma}{\ternary{e_1}{e_2}{e_3}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Paren}]
  {\forall i \leq n . \exprjudge{\Delta}{\Gamma}{e_i}{\tau_i}}
  {\exprjudge{\Delta}{\Gamma}{\paren{\seq{e}}}{\tau_n}}
\\ \\
\inferrule* [lab=\rel{T-Unop}]
  {\mathit{unop} : \_ \land \funty{\sigma}{\tau} \land \_ \\
   \exprjudge{\Delta}{\Gamma}{e}{\sigma}}
  {\exprjudge{\Delta}{\Gamma}{\mathit{unop}\ e}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Binop}]
  {\mathit{binop} : \_ \land \funty{\sigma_1, \sigma_2}{\tau} \land \_ \\\\
   \exprjudge{\Delta}{\Gamma}{e_1}{\sigma_1} \\
   \exprjudge{\Delta}{\Gamma}{e_2}{\sigma_2}}
  {\exprjudge{\Delta}{\Gamma}{e_1\ \mathit{binop}\ e_2}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-Sub}]
  {\exprjudge{\Delta}{\Gamma}{e}{\sigma} \\
   \sigma <: \tau}
  {\exprjudge{\Delta}{\Gamma}{e}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Cast}]
  {\exprjudge{\Delta}{\Gamma}{e}{\double}}
  {\exprjudge{\Delta}{\Gamma}{\mathjs{\~{}\~{}}e}{\signed}}
\end{array}
}
\end{array}
\]

\end{document}
