\documentclass{article}

\usepackage{mathpartir}
\usepackage{amssymb}

\newcommand{\ternary}[3]{{#1}\ \mathjs{?}\ {#2}\ \mathjs{:}\ {#3}}
\newcommand{\funcall}[2]{{#1}\mathjs{(}{#2}\mathjs{)}}
\newcommand{\paren}[1]{\mathjs{(}{#1}\mathjs{)}}
\newcommand{\dom}{\mathit{dom}}
\newcommand{\type}{\mathit{type}}
\newcommand{\funty}[2]{({#1}) \rightarrow {#2}}
\newcommand{\seq}[1]{\overline{{#1}}}
\newcommand{\mathjs}[1]{\mbox{\texttt{{#1}}}}
\newcommand{\mathjssm}[1]{\mbox{\texttt{\scriptsize {#1}}}}
\newcommand{\return}[1]{\mathjs{return }{#1}\mathjs{;}}
\newcommand{\fun}[3]{\mathjs{function }{#1}\mathjs{(}{#2}\mathjs{) \{ }{#3}\mathjs{ \}}}
\newcommand{\afun}[2]{\mathjs{function}\mathjs{(}{#1}\mathjs{) \{ }{#2}\mathjs{ \}}}
\newcommand{\var}[1]{\mathjs{var }{#1}\mathjs{;}}
\newcommand{\rel}[1]{\scriptsize [\textsc{#1}]}
\newcommand\defeq{\stackrel{\mbox{\tiny def}}{=}}
\newcommand{\while}[2]{\mathjs{while (}{#1}\mathjs{) }{#2}}
\newcommand{\dowhile}[2]{\mathjs{do }{#1}\mathjs{ while (}{#2}\mathjs{);}}
\newcommand{\for}[4]{\mathjs{for (}{#1}\mathjs{; }{#2}\mathjs{; }{#3}\mathjs{) }{#4}}
\newcommand{\switch}[2]{\mathjs{switch (}{#1}\mathjs{) \{ }{#2}\mathjs{ \}}}
\newcommand{\switchdef}[3]{\mathjs{switch (}{#1}\mathjs{) \{ }{#2}\mathjs{ default:}\,{#3}\mathjs{ \}}}
\newcommand{\brk}{\mathjs{break;}}
\newcommand{\brkl}[1]{\mathjs{break }{#1}\mathjs{;}}
\newcommand{\cont}{\mathjs{continue;}}
\newcommand{\contl}[1]{\mathjs{continue }{#1}\mathjs{;}}
\newcommand{\lab}[2]{{#1}\mathjs{:}\,{#2}}
\newcommand{\ifthen}[2]{\mathjs{if (}{#1}\mathjs{) }{#2}}
\newcommand{\ifthenelse}[3]{\mathjs{if (}{#1}\mathjs{) }{#2}\mathjs{ else }{#3}}
\newcommand{\block}[1]{\mathjs{\{ }{#1}\mathjs{ \}}}
\newcommand{\ok}{\mathrm{\mathbf{ok}}}
\newcommand{\rulebreak}{\vspace{.1in}\\}
\newcommand{\bit}{\mathtt{bit}}
\newcommand{\unsigned}{\mathtt{unsigned}}
\newcommand{\intsm}{\mathjssm{int}}
\newcommand{\doublesm}{\mathjssm{double}}
\newcommand{\signed}{\mathtt{signed}}
\newcommand{\double}{\mathtt{double}}
\newcommand{\arr}[2]{\mathtt{array}^{#1}_{#2}}
\newcommand{\Fun}{\mathtt{Function}}
\newcommand{\jsval}{\mathtt{jsval}}
\newcommand{\unk}{\mathtt{unknown}}
\newcommand{\str}{\mathtt{string}}
\newcommand{\undef}{\mathtt{undefined}}
\newcommand{\void}{\mathtt{void}}
\newcommand{\nul}{\mathtt{null}}
\newcommand{\num}{\mathtt{number}}
\newcommand{\obj}{\mathtt{object}}
\newcommand{\mustret}{\mathsf{return}}
\newcommand{\seqcomp}{\mathrel{;}}
\newcommand{\getprop}[2]{{#1}\mathjs{[}{#2}\mathjs{]}}
\newcommand{\getpropsm}[2]{{#1}\mathjssm{[}{#2}\mathjssm{]}}
\newcommand{\longlong}[2]{\mathjs{[}{#1},{#2}\mathjs{]}}
\newcommand{\toint}[1]{{#1}\mathjs{ | 0}}
\newcommand{\touint}[1]{{#1}\mathjs{ >>> 0}}
\newcommand{\tobits}[1]{\mathjs{\~{}\~{}}{#1}}
\newcommand{\tofloat}[1]{\mathjs{+}{#1}}
\renewcommand{\int}{\mathtt{int}}
\newcommand{\dword}{\mathtt{bits64}}
\newcommand{\function}{\mathtt{function}}
\newcommand{\union}[2]{{#1}\mathrel{|}{#2}}
\newcommand{\boolish}{\mathtt{boolish}}
\newcommand{\floor}{\mathtt{floor}}
\newcommand{\imul}{\mathtt{imul}}
\newcommand{\intish}{\mathtt{intish}}

\newcommand{\progjudge}[1]{\vdash {#1}\ \ok}
\newcommand{\impjudge}[4]{{#1};{#2};{#3} \vdash {#4}\ \ok}
\newcommand{\fnjudge}[2]{{#1} \vdash {#2}\ \ok}
\newcommand{\expjudge}[2]{{#1} \vdash {#2}\ \ok}
\newcommand{\stmtjudge}[5]{{#1};{#2} \vdash {#3} : {#4} / {#5}}
\newcommand{\exprjudge}[3]{{#1} \vdash {#2} : {#3}}
%% \newcommand{\notexprjudge}[3]{{#1} \not\vdash {#2} : {#3}}
\newcommand{\casejudge}[6]{{#1};{#2} \vdash {#3} : {#4}, {#5} / {#6}}

\begin{document}

\title{\texttt{asm.js}}
\author{Dave Herman, Luke Wagner, and Alon Zakai}
\maketitle

\section{Abstract syntax}

\[
\begin{array}{rcl}
b, e, f, g, x, y, z               & \in & \mathit{Identifier} \\
\mathtt{arguments}, \mathtt{eval} & \not\in & \mathit{Identifier} \\
\end{array}
\]

\[
\begin{array}{rcl}
P               & ::= & \function\paren{b, e}\mathjs{ \{ } \seq{\mathit{imp}_x}\ \seq{\mathit{fn}_f}\ \mathit{exp}\mathjs{ \}} \\
\mathit{imp}_x  & ::= & \var{x \mathjs{ = } e\mathjs{.}y} \\
                &  |  & \var{x \mathjs{ = } \mathjs{new }\funcall{e\mathjs{.}y}{b}} \\
\mathit{exp}    & ::= & \return{f} \\
                &  |  & \return{\mathjs{\{ } \seq{x \mathjs{:} f} \mathjs{ \}}} \\
\mathit{fn}_f   & ::= & \fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \var{\seq{y\mathjs{ = }v}}\ \mathit{ss}} \\
\end{array}
\]

\[
\begin{array}{rcl}
s & ::= & \block{\mathit{ss}} \\
  &  |  & e\mathjs{;} \\
  &  |  & \mathjs{;} \\
  &  |  & \ifthen{e}{s} \\
  &  |  & \ifthenelse{e}{s}{s} \\
  &  |  & \return{v} \\
  &  |  & \while{e}{s} \\
  &  |  & \dowhile{s}{e} \\
  &  |  & \for{e^?}{e^?}{e^?}{s} \\
  &  |  & \switch{e}{\seq{c}} \\
  &  |  & \switch{e}{\seq{c}\ d} \\
  &  |  & \brk \\
  &  |  & \brkl{\mathit{lab}} \\
  &  |  & \cont \\
  &  |  & \contl{\mathit{lab}} \\
  &  |  & \lab{\mathit{lab}}{s} \\
\\
\mathit{ss} & ::= & \seq{s} \\
\\
c & ::= & \mathjs{case }e\mathjs{:}\,\mathit{ss} \\
d & ::= & \mathjs{default:}\,\mathit{ss} \\
\mathit{cd} & ::= & c ~|~ d \\
\end{array}
\]

\[
\kappa_X ::= \tobits{X} ~|~ \tofloat{X}
\]

\[
\begin{array}{rcl}
v & ::= & r ~|~ n \\
\\
e & ::= & v \\
  &  |  & \mathit{lval} \\
  &  |  & \mathit{lval}\mathjs{ = }e \\
  &  |  & \funcall{f}{\seq{e}} \\
  &  |  & \mathit{unop}\ e \\
  &  |  & e\ \mathit{binop}\ e \\
  &  |  & \ternary{e}{e}{e} \\
  &  |  & \paren{\seq{e}} \\
\\
\mathit{unop} & ::= & \mathjs{+} ~|~ \mathjs{\~{}} ~|~ \mathjs{!} \\
\\
\mathit{binop} & ::= & \mathjs{+} ~|~ \mathjs{-} ~|~ \mathjs{*} ~|~ \mathjs{/} ~|~ \mathjs{\%} \\
               &  |  & \mathjs{|} ~|~ \mathjs{\&} ~|~ \mathjs{\^{}} ~|~ \mathjs{<<} ~|~ \mathjs{>>} ~|~ \mathjs{>>>} \\
               &  |  & \mathjs{<} ~|~ \mathjs{<=} ~|~ \mathjs{>} ~|~ \mathjs{>=} ~|~ \mathjs{!=} ~|~ \mathjs{==} \\
\mathit{lval} & ::= & x ~|~ \getprop{x}{\paren{e\mathjs{ \& }m}\mathjs{ >> }n} \\
\end{array}
\]

\section{Type rules}

\[
\begin{array}{rcl}
\sigma, \tau & ::= & \bit ~|~ \int ~|~ \boolish \\
             &  |  & \signed ~|~ \unsigned \\
             &  |  & \double \\
             &  |  & \arr{n}{\tau} ~|~ \function ~|~ \unk ~|~ \jsval \\
             &  |  & \intish \\
             &  |  & \imul \\
             &  |  & (\funty{\seq{\sigma}}{\tau}) \land \ldots \land (\funty{\seq{\sigma'}}{\tau'}) \\
             &  |  & \void \\
\end{array}
\]

\[
\begin{array}{rcl}
\ell        & ::= & \mathit{lab} ~|~ \epsilon \\
L           & ::= & \{ \seq{\ell} \} \\
\varepsilon & ::= & L ~|~ \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
L                       \seqcomp L'       & = & L \cup L' \\
\emptyset               \seqcomp \mustret & = & \mustret \\
\{ \ell, \seq{\ell'} \} \seqcomp \mustret & = & \{ \ell, \seq{\ell'} \} \\
\mustret                \seqcomp L        & = & \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
L        \cup \mustret & = & L \\
\mustret \cup L        & = & L \\
\mustret \cup \mustret & = & \mustret \\
\end{array}
\]

\[
\begin{array}{rcl}
\type(\tobits{X})  & = & \int \\
\type(\tofloat{X}) & = & \double \\
\type(n)           & = & \int \\
\type(r)           & = & \double \\
\end{array}
\]

%% NOTE: pure pointers will not be jsval

\[
\begin{array}{rcl}
\signed, \unsigned                                                                  & <: & \int, \jsval \\
\bit, \int                                                                          & <: & \boolish \\
\void, \double, \arr{n}{\tau}, \function, \unk                                      & <: & \jsval \\
\unk, \int                                                                          & <: & \intish \\
(\funty{\seq{\sigma}_1}{\tau_1}) \land \ldots \land (\funty{\seq{\sigma}_n}{\tau_n}) & <: & (\funty{\seq{\sigma}_1}{\tau_1}) \land \ldots \land (\funty{\seq{\sigma}_{n-1}}{\tau_{n-1}}) \\
\imul                                                                               & <: & \funty{\intish, \intish}{\signed} \\
\end{array}
\]

\[
\Gamma ::= \{ \seq{x : \tau} \} ~|~ \Gamma, \{ \seq{x : \tau} \}
\]

\[
\begin{array}{rcl}
M(\imul) & : & \imul \\
M(\mathtt{ceil}), M(\mathtt{sin}), M(\mathtt{cos}) & : & \funty{\double}{\double} \\
\end{array}
\]

\[
\begin{array}{rcl}
A(\mathtt{Uint8Array}), A(\mathtt{Int8Array})   & = & \arr{8}{\intsm} \\
A(\mathtt{Uint16Array}), A(\mathtt{Int16Array}) & = & \arr{16}{\intsm} \\
A(\mathtt{Uint32Array}), A(\mathtt{Int32Array}) & = & \arr{32}{\intsm} \\
A(\mathtt{Float32Array})                        & = & \arr{32}{\doublesm} \\
A(\mathtt{Float64Array})                        & = & \arr{64}{\doublesm} \\
\end{array}
\]

\[
\begin{array}{rcc@{\ }l}
\mathjs{+}, \mathjs{-}
                 & : &       & \funty{\double, \double}{\double} \\
                 &   & \land & \funty{\int, \int}{\intish} \\
\mathjs{*}       & : &       & \funty{\double, \double}{\double} \\
\mathjs{/}, \mathjs{\%}
                 & : &       & \funty{\double, \double}{\double} \\
                 &   & \land & \funty{\signed, \signed}{\intish}  \\
                 &   & \land & \funty{\unsigned, \unsigned}{\intish} \\
\\
\mathjs{|}, \mathjs{\&}, \mathjs{\^{}}, \mathjs{<<}, \mathjs{>>}
                 & : &       & \funty{\intish, \intish}{\signed} \\
\mathjs{>>>}     & : &       & \funty{\intish, \intish}{\unsigned} \\
\\
\mathjs{<}, \mathjs{<=}, \mathjs{>}, \mathjs{>=}, \mathjs{==}, \mathjs{!=}
                 & : &       & \funty{\signed, \signed}{\bit} \\
                 &   & \land & \funty{\unsigned, \unsigned}{\bit} \\
                 &   & \land & \funty{\double, \double}{\bit} \\
\\
\mathjs{+}       & : &       & \funty{\intish}{\double} \\
\mathjs{\~{}}    & : &       & \funty{\intish}{\signed} \\
\mathjs{!}       & : &       & \funty{\boolish}{\bit} \\
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Program checking} & \hfil \fbox{$\progjudge{P}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Program}]
  {\{ \seq{x} \} \cap \{ \seq{f} \} = \emptyset \\
   \{ \seq{x} \} \cap \{ b, e \} = \emptyset \\
   \{ \seq{f} \} \cap \{ b, e \} = \emptyset \\\\
   \forall i . \impjudge{b}{e}{\Gamma_0}{\mathit{imp}_x} \\
   \forall i . \fnjudge{\Gamma_0, \Gamma_1}{\mathit{fn}_f} \\
   \forall i . \expjudge{\Gamma_0, \Gamma_1}{\mathit{exp}}}
  {\progjudge{\function(b,e)\mathjs{ \{ }\seq{\mathit{imp}_x}\ \seq{\mathit{fn}_f}\ \mathit{exp}\mathjs{ \}}}}
\end{array}
}
\\ \\
\mbox{Import checking} & \hfil \fbox{$\impjudge{b}{e}{\Gamma}{\mathit{imp}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-ImportStd}]
  {\Gamma(x) = M(y)}
  {\impjudge{b}{e}{\Gamma}{\var{x \mathjs{ = } e\mathjs{.}y}}}
\qquad
\inferrule* [lab=\rel{T-ImportFFI}]
  {y \not\in\dom(M) \\
   \Gamma(x) = \function}
  {\impjudge{b}{e}{\Gamma}{\var{x \mathjs{ = } e\mathjs{.}y}}}
\\ \\
\inferrule* [lab=\rel{T-View}]
  {\Gamma(x) = \arr{n}{A(y)}}
  {\impjudge{b}{e}{\Gamma}{\var{x \mathjs{ = } e\mathjs{.}y(b)}}}
\qquad
\inferrule* [lab=\rel{T-NewView}]
  {\Gamma(x) = \arr{n}{A(y)}}
  {\impjudge{b}{e}{\Gamma}{\var{x \mathjs{ = new } e\mathjs{.}y(b)}}}
\end{array}
}
\\ \\
\mbox{Function checking} & \hfil \fbox{$\fnjudge{\Gamma}{\mathit{fn}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Function}]
  {\{ \seq{x} \} \cap \{ \seq{y} \} = \emptyset \\
   \Gamma(f) = \funty{\seq{\sigma}}{\tau} \\
   \seq{\sigma} = \seq{\type(\kappa_x)} \\
   \tau \not= \void \\\\
   \stmtjudge{\Gamma, \{ \seq{x : \sigma}, \seq{y : \type(v)} \}}{\emptyset}{\mathit{ss}}{\tau}{\mustret}}
  {\fnjudge{\Gamma}{\fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \var{\seq{y\mathjs{ = }v}}\ \mathit{ss}}}}
\\ \\
\inferrule* [lab=\rel{T-VoidFunction}]
  {\{ \seq{x} \} \cap \{ \seq{y} \} = \emptyset \\
   \Gamma(f) = \funty{\seq{\sigma}}{\void} \\
   \seq{\sigma} = \seq{\type(\kappa_x)} \\\\
   \stmtjudge{\Gamma, \{ \seq{x : \sigma}, \seq{y : \type(v)} \}}{\emptyset}{\mathit{ss}}{\void}{\varepsilon}}
  {\fnjudge{\Gamma}{\fun{f}{\seq{x}}{\seq{x\mathjs{ = }\kappa_x\mathjs{;}}\ \var{\seq{y\mathjs{ = }v}}\ \mathit{ss}}}}
\end{array}
}
\\ \\
\mbox{Export checking} & \hfil \fbox{$\expjudge{\Gamma}{\mathit{exp}}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
%% FIXME: args should be <: jsval as well
\inferrule* [lab=\rel{T-Singleton}]
  {\Gamma(f) = \funty{\seq{\sigma}}{\tau} \\
   \tau <: \jsval }
  {\expjudge{\Gamma}{\return{f}}}
\qquad
\inferrule* [lab=\rel{T-Module}]
  {\forall f . \Gamma(f) = \funty{\seq{\sigma}}{\tau} \land \tau <: \jsval}
  {\expjudge{\Gamma}{\return{\mathjs{\{ } \seq{x \mathjs{:} f} \mathjs{ \}}}}}
\end{array}
}
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Statement list checking} & \hfil \fbox{$\stmtjudge{\Gamma}{L}{\mathit{ss}}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-NoStatements}]
  { }
  {\stmtjudge{\Gamma}{L}{\epsilon}{\tau}{\emptyset}}
\qquad
\inferrule* [lab=\rel{T-Statements}]
  {\forall i . \stmtjudge{\Gamma}{L}{s_i}{\tau}{\varepsilon_i} \\\\
   n > 0 \\
   \varepsilon = \varepsilon_1 \seqcomp \ldots \seqcomp \varepsilon_n}
  {\stmtjudge{\Gamma}{L}{\seq{s}}{\tau}{\varepsilon}}
\end{array}
}
\\ \\
\mbox{Statement checking} & \hfil \fbox{$\stmtjudge{\Gamma}{L}{s}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Block}]
  {\stmtjudge{\Gamma}{\emptyset}{\mathit{ss}}{\tau}{\varepsilon}}
  {\stmtjudge{\Gamma}{L}{\block{\mathit{ss}}}{\tau}{\varepsilon}}
\qquad
\inferrule* [lab=\rel{T-ExprStmt}]
  {\exprjudge{\Gamma}{e}{\sigma}}
  {\stmtjudge{\Gamma}{L}{e\mathjs{;}}{\tau}{\emptyset}}
\\ \\
\inferrule* [lab=\rel{T-If}]
  {\exprjudge{\Gamma}{e}{\boolish} \\\\
   \stmtjudge{\Gamma}{\emptyset}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \varepsilon \cup \emptyset}
  {\stmtjudge{\Gamma}{L}{\ifthen{e}{s}}{\tau}{\varepsilon'}}
\qquad
\inferrule* [lab=\rel{T-IfElse}]
  {\exprjudge{\Gamma}{e}{\boolish} \\\\
   \stmtjudge{\Gamma}{\emptyset}{s_1}{\tau}{\varepsilon_1} \\
   \stmtjudge{\Gamma}{\emptyset}{s_2}{\tau}{\varepsilon_2} \\\\
   \varepsilon = \varepsilon_1 \cup \varepsilon_2}
  {\stmtjudge{\Gamma}{L}{\ifthenelse{e}{s_1}{s_2}}{\tau}{\varepsilon}}
\\ \\
\inferrule* [lab=\rel{T-ReturnExpr}]
  {\exprjudge{\Gamma}{e}{\tau}}
  {\stmtjudge{\Gamma}{L}{\return{e}}{\tau}{\mustret}}
\qquad
\inferrule* [lab=\rel{T-ReturnVoid}]
  { }
  {\stmtjudge{\Gamma}{L}{\mathtt{return;}}{\void}{\mustret}}
\\ \\
\inferrule* [lab=\rel{T-While}]
  {\exprjudge{\Gamma}{e}{\boolish} \\\\
   \stmtjudge{\Gamma}{L \cup \{ \epsilon \}}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \emptyset \cup \varepsilon - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\while{e}{s}}{\tau}{\varepsilon'}}
\qquad
\inferrule* [lab=\rel{T-DoWhile}]
  {\stmtjudge{\Gamma}{L \cup \{ \epsilon \}}{s}{\tau}{\varepsilon} \\\\
   \exprjudge{\Gamma}{e}{\boolish} \\\\
   \varepsilon' = \varepsilon - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\dowhile{s}{e}}{\tau}{\varepsilon'}}
\\ \\
\inferrule* [lab=\rel{T-For}]
  {e^?_1 = \varepsilon \lor \exprjudge{\Gamma}{e^?_1}{\sigma_1} \\
   e^?_2 = \varepsilon \lor \exprjudge{\Gamma}{e^?_2}{\boolish} \\
   e^?_3 = \varepsilon \lor \exprjudge{\Gamma}{e^?_3}{\sigma_3} \\\\
   \stmtjudge{\Gamma}{L \cup \{ \epsilon \}}{s}{\tau}{\varepsilon} \\
   \varepsilon' = \emptyset \cup \varepsilon - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\for{e_1}{e_2}{e_3}{s}}{\tau}{\varepsilon'}}
\end{array}
}
\end{array}
\]

\[
\begin{array}{lr}
\mbox{Statement checking (cont'd)} & \hfil \fbox{$\stmtjudge{\Gamma}{L}{s}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Break}]
  { }
  {\stmtjudge{\Gamma}{L}{\brk}{\tau}{\{ \epsilon \}}}
\qquad
\inferrule* [lab=\rel{T-BreakLabel}]
  { }
  {\stmtjudge{\Gamma}{L}{\brkl{\mathit{lab}}}{\tau}{\{ \mathit{lab} \}}}
\\ \\
\inferrule* [lab=\rel{T-Continue}]
  { }
  {\stmtjudge{\Gamma}{L}{\cont}{\tau}{\emptyset}}
\qquad
\inferrule* [lab=\rel{T-ContinueLabel}]
  { }
  {\stmtjudge{\Gamma}{L}{\contl{\mathit{lab}}}{\tau}{\emptyset}}
\\ \\
\inferrule* [lab=\rel{T-Label}]
  {\stmtjudge{\Gamma}{L \cup \{ \mathit{lab} \}}{s}{\tau}{\varepsilon} \\\\
   \varepsilon' = \varepsilon - (L \cup \{ \mathit{lab} \})}
  {\stmtjudge{\Gamma}{L}{\lab{\mathit{lab}}{s}}{\tau}{\varepsilon'}}
\\ \\
%% FIXME: add rule to handle empty switch
\inferrule* [lab=\rel{T-Switch}]
  {\exprjudge{\Gamma}{e}{\sigma} \\\\
   \forall i . \casejudge{\Gamma}{L \cup \{ \epsilon \}}{c_i}{\sigma}{\tau}{\varepsilon_i} \\\\
   \casejudge{\Gamma}{L \cup \{ \epsilon \}}{\mathit{cd}}{\sigma}{\tau}{\varepsilon} \\\\
   \varepsilon \not= \mustret \lor \exists i . \varepsilon_i \cup \emptyset \not= \emptyset \\\\
   \varepsilon' = (\varepsilon \cup \bigcup_i \varepsilon_i) - (L \cup \{ \epsilon \})}
  {\stmtjudge{\Gamma}{L}{\switch{e}{\seq{c}\ \mathit{cd}}}{\tau}{\varepsilon'}}
\qquad
\inferrule* [lab=\rel{T-SwitchReturn}]
  {\exprjudge{\Gamma}{e}{\sigma} \\\\
   \forall i . \casejudge{\Gamma}{L \cup \{ \epsilon \}}{c_i}{\sigma}{\tau}{\varepsilon_i} \\\\
   \forall i . \varepsilon_i \cup \emptyset = \emptyset \\\\
   \casejudge{\Gamma}{L \cup \{ \epsilon \}}{\mathit{cd}}{\sigma}{\tau}{\mustret}}
  {\stmtjudge{\Gamma}{L}{\switch{e}{\seq{c}\ \mathit{cd}}}{\tau}{\mustret}}
\\ \\
\inferrule* [lab=\rel{T-EmptySwitch}]
  {\exprjudge{\Gamma}{e}{\sigma}}
  {\stmtjudge{\Gamma}{L}{\switch{e}{}}{\tau}{\emptyset}}
\qquad
\inferrule* [lab=\rel{T-EmptyStatement}]
  { }
  {\stmtjudge{\Gamma}{L}{\mathjs{;}}{\tau}{\emptyset}}
\end{array}
}
\\ \\
\mbox{Case checking} & \hfil \fbox{$\casejudge{\Gamma}{L}{\mathit{cd}}{\sigma}{\tau}{\varepsilon}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Case}]
  {\exprjudge{\Gamma}{e}{\sigma} \\\\
   \stmtjudge{\Gamma}{L}{\mathit{ss}}{\tau}{\varepsilon}}
  {\casejudge{\Gamma}{L}{\mathjs{case }e\mathjs{:}\,\mathit{ss}}{\sigma}{\tau}{\varepsilon}}
\qquad
\inferrule* [lab=\rel{T-Default}]
  {\stmtjudge{\Gamma}{L}{\mathit{ss}}{\tau}{\varepsilon}}
  {\casejudge{\Gamma}{L}{\mathjs{default:}\,\mathit{ss}}{\sigma}{\tau}{\varepsilon}}
\end{array}
}
\end{array}
\]

%% FIXME: add update operators (+=, ++, etc)

\[
\begin{array}{lr}
\mbox{Expression checking} & \hfil \fbox{$\exprjudge{\Gamma}{e}{\tau}$}
\rulebreak
\multicolumn{2}{c}{
\begin{array}{c}
\inferrule* [lab=\rel{T-Signed}]
  { }
  {\exprjudge{\Gamma}{n}{\signed}}
\qquad
\inferrule* [lab=\rel{T-Unsigned}]
  { }
  {\exprjudge{\Gamma}{n}{\unsigned}}
\qquad
\inferrule* [lab=\rel{T-Double}]
  { }
  {\exprjudge{\Gamma}{r}{\double}}
\\ \\
\inferrule* [lab=\rel{T-VarRef}]
  {\Gamma(x) = \tau}
  {\exprjudge{\Gamma}{x}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Assign}]
  {\exprjudge{\Gamma}{e}{\Gamma(x)}}
  {\exprjudge{\Gamma}{x\mathjs{ = }e}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-Load}]
  {m = 2^k - 1 \\\\
   \Gamma(x) = \arr{n}{\tau} \\
   \exprjudge{\Gamma}{e}{\int}}
  {\exprjudge{\Gamma}{\getprop{x}{\paren{e\mathjs{ \& } m}\mathjs{ >> }n/8}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Store}]
  {m = 2^k - 1 \\
   \Gamma(x) = \arr{n}{\tau} \\\\
   \exprjudge{\Gamma}{e_1}{\int} \\
   \exprjudge{\Gamma}{e_2}{\tau}}
  {\exprjudge{\Gamma}{\getprop{x}{\paren{e_1\mathjs{ \& } m}\mathjs{ >> }n/8}\mathjs{ = }e_2}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-FunCall}]
  {\Gamma(f) = \funty{\seq{\sigma}}{\tau} \\\\
   \forall i . \exprjudge{\Gamma}{e_i}{\sigma_i}}
  {\exprjudge{\Gamma}{\funcall{f}{\seq{e}}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-FFI}]
  {\Gamma(f) = \function \\\\
   \forall i . \exprjudge{\Gamma}{e_i}{\jsval}}
  {\exprjudge{\Gamma}{\funcall{f}{\seq{e}}}{\unk}}
\\ \\
\inferrule* [lab=\rel{T-Conditional}]
  {\exprjudge{\Gamma}{e_1}{\boolish} \\\\
   \exprjudge{\Gamma}{e_2}{\tau} \\
   \exprjudge{\Gamma}{e_3}{\tau}}
  {\exprjudge{\Gamma}{\ternary{e_1}{e_2}{e_3}}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Paren}]
  {\forall i \leq n . \exprjudge{\Gamma}{e_i}{\tau_i}}
  {\exprjudge{\Gamma}{\paren{\seq{e}}}{\tau_n}}
\\ \\
\inferrule* [lab=\rel{T-Unop}]
  {\mathit{unop} : \_ \land \funty{\sigma}{\tau} \land \_ \\
   \exprjudge{\Gamma}{e}{\sigma}}
  {\exprjudge{\Gamma}{\mathit{unop}\ e}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Binop}]
  {\mathit{binop} : \_ \land \funty{\sigma_1, \sigma_2}{\tau} \land \_ \\\\
   \exprjudge{\Gamma}{e_1}{\sigma_1} \\
   \exprjudge{\Gamma}{e_2}{\sigma_2}}
  {\exprjudge{\Gamma}{e_1\ \mathit{binop}\ e_2}{\tau}}
\\ \\
\inferrule* [lab=\rel{T-Sub}]
  {\exprjudge{\Gamma}{e}{\sigma} \\
   \sigma <: \tau}
  {\exprjudge{\Gamma}{e}{\tau}}
\qquad
\inferrule* [lab=\rel{T-Cast}]
  {\exprjudge{\Gamma}{e}{\double}}
  {\exprjudge{\Gamma}{\mathjs{\~{}\~{}}e}{\signed}}
\end{array}
}
\end{array}
\]

\end{document}
